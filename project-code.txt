file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\.dockerignore
# Git
.git
.gitignore

# Docker
Dockerfile
docker-compose.yml

# Virtual environment
.venv
venv
env

# Python cache
__pycache__/
*.pyc
*.pyo
*.pyd

# IDE and editor configuration
.idea/
.vscode/
*.swp

# Local environment files (important for security)
.env
.env.*

# Test and coverage artifacts
.pytest_cache/
.coverage

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\.env.dev
DB_URL="postgresql://postgres:postgres@db:5432/abdb"
# DB_URL = 'sqlite:///db.sqlite'
SECRET_KEY="09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM="HS256"
ACCESS_TOKEN_EXPIRE_MINUTES=60
REFRESH_TOKEN_EXPIRE_MINUTES=70
PASSWORD_MAX_CHAR=8

# mailmug
# HOST=smtp.mailmug.net
# PORT=2525
# UNAME=f6c8skowhf0sevfp
# PASSWORD=55hg6qhuxqzodsdu
# SENDER=admin@mail.com

# mailhog
HOST=mail
PORT=1025
UNAME=null
PASSWORD=null
SENDER=admin@mail.com

OTP_EXPIRY_DURATION=180

REDIS_URL=redis://redis:6379/0

MAX_TRAFFIC_VAL = 10000

STORAGE_ENDPOINT=http://minio:9000
STORAGE_ACCESS_KEY=minioadmin
STORAGE_SECRET_KEY=minioadmin
STORAGE_BUCKET=ab-bucket
STORAGE_USE_SSL=False



file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\.gitignore
.venv
db.sqlite
__pycache__*

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\alembic.ini
# A generic, single database configuration.

[alembic]
# path to migration scripts
# Use forward slashes (/) also on windows to provide an os agnostic path
script_location = migrations

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library and tzdata library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to migrations/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "version_path_separator" below.
# version_locations = %(here)s/bar:%(here)s/bat:migrations/versions

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses os.pathsep.
# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
# version_path_separator = newline
#
# Use os.pathsep. Default configuration used for new projects.
version_path_separator = os

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = driver://user:pass@localhost/dbname


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARNING
handlers = console
qualname =

[logger_sqlalchemy]
level = WARNING
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S


file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\config.py
import os
from dotenv import load_dotenv

load_dotenv(".env.dev")

class Config:
  def getValByKey(key: str) -> str:
    return os.environ.get(key)







file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\core.py
from fastapi import FastAPI

app = FastAPI()

def getAllRoutes() -> list[str]:
  routes : list[str] = []
  for route in app.routes:
    if route.name and str(route.name).startswith("act:"):
      routes.append(route.name)
  return routes

@app.get("/",tags=["health"])
async def test()->str:
  return "App is running.....!"

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\db.py
from typing import Annotated
from fastapi import Depends
from sqlmodel import Session, create_engine
from config import Config

engine = create_engine(Config.getValByKey("DB_URL"),echo=True)

def get_session():
  with Session(engine) as session:
    yield session

DBSessionDep = Annotated[Session, Depends(get_session)]

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\di.py
from fastapi import Depends, BackgroundTasks
from typing import Annotated
from src.user.services.UserService import UserService
from src.menu.services.MenuService import MenuService
from src.auth.services.AuthService import AuthService
from src.role.services.RoleService import RoleService
from src.menutemplate.services.MenuTemplateService import MenuTemplateService
from db import DBSessionDep
from src.menu.repository.MenuRepositoryImp import MenuRepositoryImp
from src.user.repository.UserRepositoryImp import UserRepositoryImp
from src.auth.repository.AuthRepositoryImp import AuthRepositoryImp
from src.role.repository.RoleRepositoryImp import RoleRepositoryImp
from src.menutemplate.repository.MenuTemplateRepositoryImp import MenuTemplateRepositoryImp
from src.org.repository.OrgRepositoryImp import OrgRepositoryImp
from src.db.repository.UserOrgLinkRepositoryImp import UserOrgLinkRepositoryImp
from src.email.EmailServiceImp import EmailServiceImp
from passlib.context import CryptContext
from src.project.services.ProjectService import ProjectService
from src.project.repository.ProjectRepositoryImp import ProjectRepositoryImp
from src.db.repository.UserProjectLinkRepositoryImp import UserProjectLinkRepositoryImp
from src.org.services.OrgService import OrgService
from src.utils.FileService import FileService
from src.experiment.services.ExperimentService import ExperimentService
from src.experiment.repository.ExperimentRepositoryImp import ExperimentRepositoryImp
from src.variation.services.VariationService import VariationService
from src.variation.repository.VariationRepositoryImp import VariationRepositoryImp
from src.condition.services.ConditionService import ConditionService
from src.condition.repository.ConditionRepositoryImp import ConditionRepositoryImp
from src.metrics.services.MetricsService import MetricsService
from src.metrics.repository.MetricsRepositoryImp import MetricsRepositoryImp
from src.bucket.repository.BucketRepositoryImp import BucketRepositoryImp
from src.decision.services.DecisionService import DecisionService
from src.utils.CacheService import CacheService
from src.project.repository.ProjectRepositoryImp import ProjectRepositoryImp
from src.db.repository.UserProjectLinkRepositoryImp import UserProjectLinkRepositoryImp

def getCacheService() -> CacheService:
  return CacheService()

CacheServiceDep = Annotated[CacheService, Depends(getCacheService)]

def getUserService(db: DBSessionDep, bgTask: BackgroundTasks) -> UserService:
  crypto = CryptContext(schemes=["bcrypt"], deprecated="auto")
  userRepo = UserRepositoryImp(db)
  orgRepo = OrgRepositoryImp(db)
  userOrgLinkRepo = UserOrgLinkRepositoryImp(db)
  emailService = EmailServiceImp(bgTask)
  return UserService(userRepo, orgRepo, userOrgLinkRepo, crypto, emailService)

def getMenuService(db: DBSessionDep) -> MenuService:
  repo = MenuRepositoryImp(db)
  return MenuService(repo)

def getRoleService(db: DBSessionDep) -> RoleService:
  repo = RoleRepositoryImp(db)
  return RoleService(repo)

def getMenuTemplateService(db: DBSessionDep) -> MenuTemplateService:
  repo = MenuTemplateRepositoryImp(db)
  return MenuTemplateService(repo)

def getAuthService(db: DBSessionDep) -> AuthService:
  crypto = CryptContext(schemes=["bcrypt"], deprecated="auto")
  repo = AuthRepositoryImp(db)
  userOrgLinkRepo = UserOrgLinkRepositoryImp(db)
  userProjectLinkRepo = UserProjectLinkRepositoryImp(db)
  return AuthService(repo, crypto, userOrgLinkRepo, userProjectLinkRepo)

def getProjectService(db: DBSessionDep) -> ProjectService:
  projectRepo = ProjectRepositoryImp(db)
  userProjectLinkRepo = UserProjectLinkRepositoryImp(db)
  userOrgLinkRepo = UserOrgLinkRepositoryImp(db)
  return ProjectService(projectRepo, userProjectLinkRepo, userOrgLinkRepo)

def getFileService() -> FileService:
  return FileService()

def getOrgService(db: DBSessionDep, bgTask: BackgroundTasks) -> OrgService:
  orgRepo = OrgRepositoryImp(db)
  userRepo = UserRepositoryImp(db)
  roleRepo = RoleRepositoryImp(db)
  userOrgLinkRepo = UserOrgLinkRepositoryImp(db)
  mtRepo = MenuTemplateRepositoryImp(db)

  projectRepo = ProjectRepositoryImp(db)
  userProjectLinkRepo = UserProjectLinkRepositoryImp(db)
  
  crypto = CryptContext(schemes=["bcrypt"], deprecated="auto")
  fileService = getFileService()
  emailService = EmailServiceImp(bgTask)
  
  return OrgService(
    orgRepo, 
    userRepo, 
    roleRepo, 
    crypto, 
    fileService, 
    emailService, 
    userOrgLinkRepo, 
    mtRepo,
    projectRepo,
    userProjectLinkRepo
  )

def getExperimentService(db: DBSessionDep) -> ExperimentService:
  repo = ExperimentRepositoryImp(db)
  projectRepo = ProjectRepositoryImp(db) 
  return ExperimentService(repo, projectRepo)

def getVariationService(db: DBSessionDep) -> VariationService:
  repo = VariationRepositoryImp(db)
  experimentRepo = ExperimentRepositoryImp(db)
  return VariationService(repo, experimentRepo)

def getConditionService(db: DBSessionDep, cache: CacheServiceDep) -> ConditionService:
  repo = ConditionRepositoryImp(db)
  experimentRepo = ExperimentRepositoryImp(db)
  return ConditionService(repo, experimentRepo, cache)

def getMetricsService(db: DBSessionDep) -> MetricsService:
  repo = MetricsRepositoryImp(db)
  experimentRepo = ExperimentRepositoryImp(db)
  return MetricsService(repo, experimentRepo)

def getDecisionService(db: DBSessionDep, cache: CacheServiceDep) -> DecisionService:
  bucketRepo = BucketRepositoryImp(db)
  experimentRepo = ExperimentRepositoryImp(db)
  return DecisionService(bucketRepo, experimentRepo, cache)

UserServiceDep = Annotated[UserService, Depends(getUserService)]
MenuServiceDep = Annotated[MenuService, Depends(getMenuService)]
AuthServiceDep = Annotated[AuthService, Depends(getAuthService)]
RoleServiceDep = Annotated[RoleService, Depends(getRoleService)]
MenuTemplateServiceDep = Annotated[MenuTemplateService, Depends(getMenuTemplateService)]
ProjectServiceDep = Annotated[ProjectService, Depends(getProjectService)]
OrgServiceDep = Annotated[OrgService, Depends(getOrgService)]
ExperimentServiceDep = Annotated[ExperimentService, Depends(getExperimentService)]
VariationServiceDep = Annotated[VariationService, Depends(getVariationService)]
ConditionServiceDep = Annotated[ConditionService, Depends(getConditionService)]
MetricsServiceDep = Annotated[MetricsService, Depends(getMetricsService)]
DecisionServiceDep = Annotated[DecisionService, Depends(getDecisionService)]


file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\docker-compose.yml
version: "3.8"

services:
  web:
    build: .
    ports:
      - "8000:8000"
      - "5678:5678"
    volumes:
      - .:/app
    env_file:
      - .env.dev
    depends_on:
      db:
        condition: service_healthy # Wait for DB to be actually ready
      redis:
        condition: service_started # Wait for Redis container
    command:
      [
        "python",
        "-m",
        "debugpy",
        "--listen",
        "0.0.0.0:5678",
        "-m",
        "uvicorn",
        "main:app",
        "--host",
        "0.0.0.0",
        "--port",
        "8000",
        "--reload",
      ]

  db:
    image: postgres:13
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=abdb
    ports:
      - "5433:5432"
    # CRITICAL: Healthcheck prevents app from connecting before DB is ready
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:alpine
    ports:
      - "6379:6379"

  mail:
    image: mailhog/mailhog
    container_name: ab-mail
    ports:
      - "1025:1025" # SMTP port (for your app to send mail)
      - "8025:8025" # Web UI port (for you to view mail)
    networks:
      - default

  minio:
    image: minio/minio
    container_name: ab-storage
    ports:
      - "9000:9000" # API Port (for your app)
      - "9001:9001" # Console Port (for your browser)
    environment:
      - MINIO_ROOT_USER=minioadmin
      - MINIO_ROOT_PASSWORD=minioadmin
    command: server /data --console-address ":9001"
    volumes:
      - minio_data:/data

volumes:
  postgres_data:
  minio_data:


file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\docker-db.session.sql
SELECT * FROM experiment;
-- SELECT * FROM userorglin
-- SELECT * FROM organization;
-- SELECT * FROM role;
-- SELECT * FROM menutemplate;
-- SELECT * FROM alembic_version;
-- DELETE FROM userinfo;
-- DELETE FROM organization;
-- DELETE FROM userorglink;

-- UPDATE userinfo SET disabled = false WHERE id='1';

-- DELETE FROM alembic_version WHERE version_num = 'b97a65ac9ca7';

-- DROP TABLE alembic_version;
-- DROP TABLE menu;
-- DROP TABLE userinfo;
-- DROP TABLE organization;
-- DROP TABLE action;
-- DROP TABLE userorglink;




file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\Dockerfile
# Use a newer stable Python version (3.12) as the parent image
FROM python:3.12-slim

# Set environment variables for Python
ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

# Set the working directory in the container
WORKDIR /app

# Install system dependencies
# libpq-dev is required to compile psycopg2 from source
RUN apt-get update && apt-get install -y \
    build-essential \
    libpq-dev \
    && apt-get clean && rm -rf /var/lib/apt/lists/*

# Copy only the requirements file first to leverage Docker caching
COPY requirements.txt .

# Install Python dependencies.
# Note: Ensure 'psycopg2', 'mmh3', and 'redis' are in your requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

# Now, copy the rest of the application code.
COPY . .

# Expose the port
EXPOSE 8000

# Command to run the application
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\main.py
from fastapi import Depends, Header
from src.user import UserRouter
from src.user import UserInsecureRouter
from src.menu import MenuRouter
from src.auth import AuthRouter
from src.role import RoleRouter
from src.menutemplate import MenuTemplateRouter
from src.auth.AuthMiddleware import AuthMiddleware
from fastapi.security import HTTPBearer
from typing import Annotated
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from src.action import ActionRouter
from src.project import ProjectRouter
from src.org import OrgRouter
from src.experiment import ExperimentRouter 
from src.variation import VariationRouter
from src.condition import ConditionRouter
from src.metrics import MetricsRouter
from src.metrics import MetricsInsecureRouter
from src.decision import DecisionRouter
from core import app

# IMPORT Models
from src.user.model.User import User
from src.org.model.Organization import Organization
from src.menu.model.Menu import Menu
from src.role.model.Role import Role
from src.menutemplate.model.MenuTemplate import MenuTemplate
from src.experiment.model.Experiment import Experiment
from src.variation.model.Variation import Variation
from src.condition.model.Condition import Condition
from src.metrics.model.Metrics import Metrics
from src.bucket.model.Bucket import Bucket
from src.db.links.UserOrgLink import UserOrgLink
from src.db.links.UserProjectLink import UserProjectLink
from src.project.model.Project import Project

def getEmail(email: Annotated[str, Header()]):
  return email

app.include_router(UserRouter.routes, dependencies=[Depends(getEmail), Depends(HTTPBearer())])
app.include_router(MenuRouter.routes, dependencies=[Depends(getEmail), Depends(HTTPBearer())])
app.include_router(RoleRouter.routes, dependencies=[Depends(getEmail), Depends(HTTPBearer())])
app.include_router(MenuTemplateRouter.routes, dependencies=[Depends(getEmail), Depends(HTTPBearer())])
app.include_router(ActionRouter.routes, dependencies=[Depends(getEmail), Depends(HTTPBearer())])
app.include_router(ProjectRouter.routes, dependencies=[Depends(getEmail), Depends(HTTPBearer())])
app.include_router(ExperimentRouter.routes, dependencies=[Depends(getEmail), Depends(HTTPBearer())])
app.include_router(VariationRouter.routes, dependencies=[Depends(getEmail), Depends(HTTPBearer())])
app.include_router(ConditionRouter.routes, dependencies=[Depends(getEmail), Depends(HTTPBearer())])
app.include_router(MetricsRouter.routes, dependencies=[Depends(getEmail), Depends(HTTPBearer())])
app.include_router(MetricsInsecureRouter.routes)
app.include_router(DecisionRouter.routes)
app.include_router(AuthRouter.routes)
app.include_router(UserInsecureRouter.routes)
app.include_router(OrgRouter.routes)

app.add_middleware(AuthMiddleware)

origins = [
  "http://localhost:3000",  
  "http://127.0.0.1:3000",
  "http://localhost:3030"
]

app.add_middleware(
  CORSMiddleware,
  allow_origins=origins,             
  allow_credentials=True,            
  allow_methods=["*"],        
  allow_headers=["*"],               
)

app.mount("/static", StaticFiles(directory="static"), name="static")

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\README.md
# ABTestingTool

ABTestingTool is a **user, role, menu, and API access management system** built with **FastAPI**.
It also includes an **experimentation and decision engine** supporting A/B testing,
personalization, Redis caching, and PostgreSQL.

---

## üöÄ Features

- JWT-based Authentication & Refresh Tokens
- User & Organization Management
- Role & Permission System
- Menu & Menu Template Management
- API Access Control
- Experimentation Platform (A/B Testing, Personalization)
- Targeting Conditions & Variations
- Metrics Tracking
- Decision Engine with Bucketing
- Redis-based Caching
- Fully Dockerize Setup
- Alembic Database Migrations
- Email-based OTP & Notifications (Mailmug for development)

---

## üõ† Tech Stack

- Backend: FastAPI
- Database: PostgreSQL (SQLModel + SQLAlchemy)
- Cache: Redis
- Authentication: JWT (Access & Refresh Tokens)
- Migrations: Alembic
- Containerization: Docker & Docker Compose
- Python Version: 3.12+

---

## üìÇ Project Structure (High Level)

    ABTestingTool/
    ‚îú‚îÄ‚îÄ src/                 Application source code
    ‚îú‚îÄ‚îÄ migrations/          Alembic migrations
    ‚îú‚îÄ‚îÄ main.py              Application entry point
    ‚îú‚îÄ‚îÄ core.py              FastAPI app instance
    ‚îú‚îÄ‚îÄ db.py                Database session & engine
    ‚îú‚îÄ‚îÄ di.py                Dependency injection
    ‚îú‚îÄ‚îÄ Dockerfile
    ‚îú‚îÄ‚îÄ docker-compose.yml
    ‚îú‚îÄ‚îÄ requirements.txt
    ‚îú‚îÄ‚îÄ .env.dev
    ‚îî‚îÄ‚îÄ README.md

---

## üê≥ Run With Docker (Recommended)

### Build & Start Services

    docker-compose up --build

Services started:

- FastAPI: http://localhost:8000
- PostgreSQL: localhost:5433
- Redis: localhost:6379

### Generate migration:

    docker-compose exec web alembic revision --autogenerate -m "init"

### Run Database Migrations

    docker-compose exec web alembic upgrade head

### API Documentation

- Swagger UI: http://localhost:8000/docs
- OpenAPI JSON: http://localhost:8000/openapi.json

---

## üßë‚Äçüíª Run Without Docker (Local Development)

### 1Ô∏è‚É£ Create Virtual Environment

    python -m venv venv

Activate it:

Windows:
venv\Scripts\activate

Linux / macOS:
source venv/bin/activate

---

### 2Ô∏è‚É£ Install Dependencies

    pip install -r requirements.txt

---

### 3Ô∏è‚É£ Configure Environment

Create `.env.dev`

SQLite (local testing):

    DB_URL=sqlite:///db.sqlite

---

### 4Ô∏è‚É£ Database Migration Commands

Initialize migrations (first time only):

    alembic init migrations

Generate migration:

    alembic revision --autogenerate -m "init"

Apply migrations:

    alembic upgrade head

---

### 5Ô∏è‚É£ Start Development Server

Using Uvicorn:

    uvicorn main:app --reload

Or using FastAPI CLI:

    fastapi dev main.py

Server URL:
http://127.0.0.1:8000

---

## üîê Authentication Notes

Most endpoints require these headers:

    Authorization: Bearer <access_token>
    email: user@example.com

Public endpoints include:

- /
- /auth/login
- /auth/refresh
- /users/registration
- /users/verify

---

## üß™ Decision Engine Flow

1. Client calls /decision
2. Active experiments fetched (Redis ‚Üí DB fallback)
3. Targeting rules evaluated
4. Bucketing ensures consistent variation assignment
5. Response includes:
   - Experiment
   - Variation
   - Conditions
   - Metrics

---

## üìß Mail Service

For development purposes, **Mailmug/MailHog** is used to send:

- Account verification OTP
- Forgot password OTP
- Open the MailHog Web UI at http://localhost:8025

Mail configuration is controlled via environment variables.

---

## Local Storage

Industry-standard tool for local object storage (like Google Cloud Storage or AWS S3) in Docker is MinIO.

- Open the UI: Go to http://localhost:9001
- Login:

  - User: admin
  - Pass: admin

- Create a Bucket: You must create the bucket (e.g., ab-bucket) in the UI before your code tries to upload to it.

---

## üßπ Useful Commands

Stop Docker containers:

    docker-compose down

Remove containers and volumes (WARNING: deletes DB data):

    docker-compose down -v

Start fresh

    docker-compose up -d --build

Create a new migration:

    alembic revision --autogenerate -m "your message"

View Backend Logs

    docker-compose logs -f web

View Database Logs

    docker-compose logs -f db

---

## üìÑ License

This project is intended for **personal or internal use**.


file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\requirements.txt
psycopg2==2.9.10
alembic==1.15.2
sqlmodel==0.0.24
python-dotenv==1.1.0
bcrypt==4.1.2
passlib[bcrypt]==1.7.4
pyjwt==2.10.1
fastapi[standard]
gunicorn
httptools==0.7.1
mmh3==5.2.0
redis==5.0.1
debugpy==1.8.0

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\migrations\env.py
from logging.config import fileConfig
from pathlib import Path
from sqlalchemy import engine_from_config
from sqlalchemy import pool
from sqlmodel import SQLModel
from alembic import context
from config import Config
from src.user.model.User import User
from src.menu.model.Menu import Menu
from src.org.model.Organization import Organization
from src.db.links.UserOrgLink import UserOrgLink
from src.role.model.Role import Role
from src.menutemplate.model.MenuTemplate import MenuTemplate
from src.experiment.model.Experiment import Experiment
from src.variation.model.Variation import Variation
from src.condition.model.Condition import Condition
from src.metrics.model.Metrics import Metrics
from src.bucket.model.Bucket import Bucket
from src.project.model.Project import Project
from src.db.links.UserProjectLink import UserProjectLink

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# sqlite
# DB_PATH = str((Path().parent / 'db.sqlite').resolve())
# config.set_main_option('sqlalchemy.url',f"sqlite:///{DB_PATH}")

# postgresql
config.set_main_option('sqlalchemy.url', Config.getValByKey("DB_URL"))

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = SQLModel.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\migrations\README
Generic single-database configuration.

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\migrations\script.py.mako
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
import sqlmodel
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}

def upgrade() -> None:
    """Upgrade schema."""
    ${upgrades if upgrades else "pass"}

def downgrade() -> None:
    """Downgrade schema."""
    ${downgrades if downgrades else "pass"}


file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\migrations\versions\dda253ce9217_init.py
"""init

Revision ID: dda253ce9217
Revises: 
Create Date: 2025-12-31 13:39:30.284150

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
import sqlmodel


# revision identifiers, used by Alembic.
revision: str = 'dda253ce9217'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('bucket',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('expId', sa.Integer(), nullable=True),
    sa.Column('endUserId', sa.Integer(), nullable=True),
    sa.Column('variationId', sa.Integer(), nullable=True),
    sa.Column('createdAt', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updatedAt', sa.DateTime(timezone=True), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('menu',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('label', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('icon', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('href', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_menu_label'), 'menu', ['label'], unique=False)
    op.create_table('organization',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('email', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('domain', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('disabled', sa.Boolean(), nullable=False),
    sa.Column('createdAt', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updatedAt', sa.DateTime(timezone=True), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('domain')
    )
    op.create_index(op.f('ix_organization_email'), 'organization', ['email'], unique=False)
    op.create_index(op.f('ix_organization_name'), 'organization', ['name'], unique=False)
    op.create_table('userinfo',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('email', sqlmodel.sql.sqltypes.AutoString(), nullable=False),
    sa.Column('password', sqlmodel.sql.sqltypes.AutoString(), nullable=False),
    sa.Column('otp', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('verified', sa.Boolean(), nullable=False),
    sa.Column('firstName', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('lastName', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('contactNumber', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('createdAt', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updatedAt', sa.DateTime(timezone=True), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_userinfo_email'), 'userinfo', ['email'], unique=False)
    op.create_table('menutemplate',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sqlmodel.sql.sqltypes.AutoString(), nullable=False),
    sa.Column('orgId', sa.Integer(), nullable=True),
    sa.Column('tree', sqlmodel.sql.sqltypes.AutoString(), nullable=False),
    sa.Column('createdAt', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updatedAt', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['orgId'], ['organization.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('project',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sqlmodel.sql.sqltypes.AutoString(), nullable=False),
    sa.Column('description', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('orgId', sa.Integer(), nullable=True),
    sa.Column('createdAt', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updatedAt', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['orgId'], ['organization.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_project_name'), 'project', ['name'], unique=False)
    op.create_table('role',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('orgId', sa.Integer(), nullable=True),
    sa.Column('createdAt', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updatedAt', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['orgId'], ['organization.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('experiment',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('js', sa.Text(), nullable=True),
    sa.Column('css', sa.Text(), nullable=True),
    sa.Column('url', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('type', sa.Enum('AB_TEST', 'PERSONALIZATION', 'SPLIT_URL', 'REDIRECT', name='experimenttype'), nullable=False),
    sa.Column('title', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('status', sa.Enum('DRAFT', 'ACTIVE', 'PAUSED', 'ARCHIVED', 'ENDED', name='experimentstatus'), nullable=False),
    sa.Column('description', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('triggerType', sa.Enum('IMMEDIATELY', 'DOM_READY', 'URL_CHANGES', name='triggertype'), nullable=False),
    sa.Column('conditionType', sa.Enum('ALL', 'ANY', name='conditiontype'), nullable=False),
    sa.Column('projectId', sa.Integer(), nullable=True),
    sa.Column('createdAt', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updatedAt', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['projectId'], ['project.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('userorglink',
    sa.Column('userId', sa.Integer(), nullable=False),
    sa.Column('orgId', sa.Integer(), nullable=False),
    sa.Column('roleId', sa.Integer(), nullable=True),
    sa.Column('menuTemplateId', sa.Integer(), nullable=True),
    sa.Column('disabled', sa.Boolean(), nullable=False),
    sa.Column('super', sa.Boolean(), nullable=False),
    sa.ForeignKeyConstraint(['menuTemplateId'], ['menutemplate.id'], ),
    sa.ForeignKeyConstraint(['orgId'], ['organization.id'], ),
    sa.ForeignKeyConstraint(['roleId'], ['role.id'], ),
    sa.ForeignKeyConstraint(['userId'], ['userinfo.id'], ),
    sa.PrimaryKeyConstraint('userId', 'orgId')
    )
    op.create_table('userprojectlink',
    sa.Column('userId', sa.Integer(), nullable=False),
    sa.Column('projectId', sa.Integer(), nullable=False),
    sa.Column('disabled', sa.Boolean(), nullable=False),
    sa.Column('super', sa.Boolean(), nullable=False),
    sa.Column('permissionType', sa.Enum('OWNER', 'EDITOR', 'VIEWER', name='permissiontype'), nullable=False),
    sa.ForeignKeyConstraint(['projectId'], ['project.id'], ),
    sa.ForeignKeyConstraint(['userId'], ['userinfo.id'], ),
    sa.PrimaryKeyConstraint('userId', 'projectId')
    )
    op.create_table('condition',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('urls', sa.ARRAY(sa.String()), nullable=True),
    sa.Column('operator', sa.Enum('NOT_CONTAIN', 'CONTAIN', 'IS', 'IS_NOT', name='operator'), nullable=False),
    sa.Column('experimentId', sa.Integer(), nullable=True),
    sa.Column('createdAt', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updatedAt', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['experimentId'], ['experiment.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('metrics',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('title', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('custom', sa.Boolean(), nullable=False),
    sa.Column('selector', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('triggeredOnLIVE', sa.Integer(), nullable=True),
    sa.Column('triggeredOnQA', sa.Integer(), nullable=True),
    sa.Column('description', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('experimentId', sa.Integer(), nullable=True),
    sa.Column('createdAt', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updatedAt', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['experimentId'], ['experiment.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('variation',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('js', sa.Text(), nullable=True),
    sa.Column('css', sa.Text(), nullable=True),
    sa.Column('title', sqlmodel.sql.sqltypes.AutoString(), nullable=True),
    sa.Column('traffic', sa.Integer(), nullable=True),
    sa.Column('isControl', sa.Boolean(), nullable=False),
    sa.Column('experimentId', sa.Integer(), nullable=True),
    sa.Column('createdAt', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updatedAt', sa.DateTime(timezone=True), nullable=True),
    sa.ForeignKeyConstraint(['experimentId'], ['experiment.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###

def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('variation')
    op.drop_table('metrics')
    op.drop_table('condition')
    op.drop_table('userprojectlink')
    op.drop_table('userorglink')
    op.drop_table('experiment')
    op.drop_table('role')
    op.drop_index(op.f('ix_project_name'), table_name='project')
    op.drop_table('project')
    op.drop_table('menutemplate')
    op.drop_index(op.f('ix_userinfo_email'), table_name='userinfo')
    op.drop_table('userinfo')
    op.drop_index(op.f('ix_organization_name'), table_name='organization')
    op.drop_index(op.f('ix_organization_email'), table_name='organization')
    op.drop_table('organization')
    op.drop_index(op.f('ix_menu_label'), table_name='menu')
    op.drop_table('menu')
    op.drop_table('bucket')
    # ### end Alembic commands ###


file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\action\ActionRouter.py
from fastapi import APIRouter
from core import app, getAllRoutes

routes = APIRouter()

@routes.post("/actions", tags=["actions"])
async def get()-> list[str]:
  return getAllRoutes()
  

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\auth\AuthMiddleware.py
import jwt
import re
from starlette.middleware.base import BaseHTTPMiddleware
from fastapi import Request, Response, status
from config import Config
from jwt import ExpiredSignatureError

class AuthMiddleware(BaseHTTPMiddleware):

  def __init__(self, app):
    super().__init__(app)

  async def dispatch(self, request: Request, call_next)-> Response:
    excludedPaths = [
      "/docs",
      "/openapi.json",
      "/auth/login", 
      "/", 
      "/auth/refresh", 
      "/users/registration",
      "/users/verify",
      "/users/forgot-password-otp",
      "/users/join-organization",
      "/static/menu.json",
      "/organizations",
      "/organizations/search",
      "/static/client-sdk.js",
      "/decision",
      "/metrics/track"
    ]

    excludedRegexs = []

    if request.url.path in excludedPaths:
      return await call_next(request)
    
    for pattern in excludedRegexs:
      if re.match(pattern, request.url.path):
        return await call_next(request)

    authorization = request.headers.get("authorization")
    authEmail = request.headers.get("email")
    
    if not authEmail:
      return Response(content="No mail found on header!",status_code=status.HTTP_403_FORBIDDEN)

    if not authorization:
      return Response(content="No authorization found!",status_code=status.HTTP_403_FORBIDDEN)

    token = authorization.split(" ")[1].strip()
    response = await self.verifyToken(token=token, authEmail=authEmail)

    if response:
      return response

    return await call_next(request)
  
  async def verifyToken(self, token: str, authEmail: str):
    try:
      payload = jwt.decode(token, Config.getValByKey("SECRET_KEY"), Config.getValByKey("ALGORITHM"))
    except ExpiredSignatureError as e:
      return Response(content="Token expired!",status_code=status.HTTP_401_UNAUTHORIZED)
    
    payloadEmail = payload.get("sub")

    if payloadEmail is None:
      return Response(content="No email found on token payload!",status_code=status.HTTP_401_UNAUTHORIZED)

    if authEmail != payloadEmail:
      raise Response(content="Auth token email didn't match with header token!", status_code=status.HTTP_404_NOT_FOUND)
    

    

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\auth\AuthRouter.py
from fastapi import APIRouter
from src.auth.dtos.LoginResponseDto import LoginResponseDto
from src.auth.dtos.LoginRequestDto import LoginRequestDto
from di import AuthServiceDep
from src.auth.dtos.AuthRefreshResponseDto import AuthRefreshResponseDto
from src.auth.dtos.AuthRefreshRequestDto import AuthRefreshRequestDto

routes = APIRouter()

@routes.post("/auth/login", response_model=LoginResponseDto, tags=["auth"])
async def login(loginRequestDto: LoginRequestDto, authService: AuthServiceDep) -> LoginResponseDto:
  return authService.login(loginRequestDto)

@routes.post("/auth/refresh", response_model=AuthRefreshResponseDto, tags=["auth"])
async def refresh(authRefreshRequestDto: AuthRefreshRequestDto, authService: AuthServiceDep) -> AuthRefreshResponseDto:
  return authService.refresh(authRefreshRequestDto)
  
  


file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\auth\dtos\AuthRefreshRequestDto.py
from dataclasses import dataclass
from pydantic import constr

@dataclass
class AuthRefreshRequestDto:
  refreshToken: constr(min_length=1) # type: ignore

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\auth\dtos\AuthRefreshResponseDto.py
from dataclasses import dataclass

@dataclass
class AuthRefreshResponseDto:
  accessToken: str
  refreshToken: str

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\auth\dtos\LoginRequestDto.py
from dataclasses import dataclass
from pydantic import constr, field_validator, EmailStr
from config import Config

@dataclass
class LoginRequestDto:
  email: EmailStr
  password: constr(min_length=1) # type: ignore

  @field_validator("password")
  def validatePassword(cls, password):
    if len(password) < int(Config.getValByKey("PASSWORD_MAX_CHAR")):
      raise ValueError(f"Password must be at least {Config.getValByKey("PASSWORD_MAX_CHAR")} characters long!")
    if not any(char.isupper() for char in password):
      raise ValueError("Password must contain at least one uppercase letter!")
    if not any(char.islower() for char in password):
      raise ValueError("Password must contain at least one lowercase letter!")
    if not any(char.isdigit() for char in password):
      raise ValueError("Password must contain at least one digit!")
    if not any(char in "!@#$%^&*()" for char in password):
      raise ValueError("Password must contain at least one special character!")
    return password

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\auth\dtos\LoginResponseDto.py
from dataclasses import dataclass

@dataclass
class LoginResponseDto:
  accessToken: str
  refreshToken: str

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\auth\dtos\tokens.py
from dataclasses import dataclass
from pydantic import constr

@dataclass
class Token:
  accessToken: constr(min_length=1) # type: ignore
  refreshToken: constr(min_length=1) # type: ignore

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\auth\repository\AuthRepository.py
from abc import ABC, abstractmethod
from src.user.model.User import User

class AuthRepository(ABC):
  
  @abstractmethod
  def getUserByEmail(self, email: str) -> User:
    pass

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\auth\repository\AuthRepositoryImp.py
from src.auth.repository.AuthRepository import AuthRepository
from di import DBSessionDep
from src.user.model.User import User
from sqlmodel import select

class AuthRepositoryImp(AuthRepository):

  def __init__(self, db: DBSessionDep):
    self.db = db

  def getUserByEmail(self, email: str) -> User:
    return self.db.exec(select(User).filter_by(email=email)).first()

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\auth\services\AuthService.py
import jwt
from passlib.context import CryptContext
from src.db.repository.UserOrgLinkRepository import UserOrgLinkRepository
from src.auth.repository.AuthRepository import AuthRepository
from src.auth.dtos.LoginRequestDto import LoginRequestDto
from src.auth.dtos.LoginResponseDto import LoginResponseDto
from src.user.model.User import User
from fastapi import status, HTTPException
from datetime import datetime, timedelta, timezone
from config import Config
from src.auth.dtos.AuthRefreshResponseDto import AuthRefreshResponseDto
from src.auth.dtos.AuthRefreshRequestDto import AuthRefreshRequestDto
from jwt import ExpiredSignatureError
from src.auth.dtos.tokens import Token
from src.db.repository.UserProjectLinkRepository import UserProjectLinkRepository

class AuthService:
  def __init__(
      self, 
      authRepository : AuthRepository, 
      crypto: CryptContext, 
      userOrgLinkRepo: UserOrgLinkRepository,
      userProjectLinkRepo: UserProjectLinkRepository
    ):
    self.repo = authRepository
    self.crypto = crypto
    self.userOrgLinkRepo = userOrgLinkRepo
    self.userProjectLinkRepo = userProjectLinkRepo

  def login(self, reqDto: LoginRequestDto) -> LoginResponseDto: # Updated return type hint
    dbUser: User = self.repo.getUserByEmail(reqDto.email)

    if not dbUser:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="No user found by this email!")
    
    if not dbUser.verified:
      raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="User not verified yet!")
  
    isPasswordVerified = self.crypto.verify(reqDto.password, dbUser.password)

    if not isPasswordVerified:
      raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect password!")
    
    # --- NEW NESTED LOGIC START ---
    activeOrgsWithProjects = []

    for org in dbUser.orgs:
      # 1. Check if User is active in this Org
      orgLink = self.userOrgLinkRepo.get(dbUser.id, org.id)
      if not orgLink or orgLink.disabled:
        continue

      # 2. Find valid projects for this specific Org
      orgProjects = []
      for project in dbUser.projects:
        # Only check projects belonging to the current loop's organization
        if project.orgId == org.id:
          projLink = self.userProjectLinkRepo.get(dbUser.id, project.id)
          
          if projLink and not projLink.disabled:
            orgProjects.append({
              "id": project.id,
              "name": project.name
            })
      
      # 3. Build the nested structure
      activeOrgsWithProjects.append({
        "id": org.id,
        "name": org.name,
        "projects": orgProjects
      })
    
    # --- NEW NESTED LOGIC END ---

    if not activeOrgsWithProjects:
      raise HTTPException(
        status_code=status.HTTP_403_FORBIDDEN, 
        detail="Your account is disabled in all organizations!"
      )

    # Note: We now pass the nested list. We no longer need a separate 'projects' argument.
    token = self.generateToken(dbUser, activeOrgsWithProjects)

    res = LoginResponseDto(accessToken=token.accessToken, refreshToken=token.refreshToken)
    return res
  
  def refresh(self, authRefreshRequestDto: AuthRefreshRequestDto)-> AuthRefreshResponseDto:
    refreshToken = authRefreshRequestDto.refreshToken

    try:
      payload = jwt.decode(refreshToken, Config.getValByKey("SECRET_KEY"), Config.getValByKey("ALGORITHM"))
    except ExpiredSignatureError as e:
      raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Token expired!")

    payloadEmail = payload.get("sub")

    if payloadEmail is None:
      raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="No email found on token payload!")
    
    dbUser: User = self.repo.getUserByEmail(payloadEmail)

    if not dbUser:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="No user found by this email!")
    
    token = self.generateToken(dbUser)

    res  = AuthRefreshResponseDto(accessToken=token.accessToken,refreshToken=token.refreshToken)
    return res
  
  def generateToken(self, user: User, orgs : list)->Token:
    accessTokenExpires = datetime.now(timezone.utc) + timedelta(minutes=int(Config.getValByKey("ACCESS_TOKEN_EXPIRE_MINUTES")))
    refreshTokenExpires = datetime.now(timezone.utc) + timedelta(minutes=int(Config.getValByKey("REFRESH_TOKEN_EXPIRE_MINUTES")))

    accessToken = jwt.encode({
      "sub" : user.email,
      "userId": user.id,
      "orgs" : orgs,
      "exp" : accessTokenExpires
    }, Config.getValByKey("SECRET_KEY"), Config.getValByKey("ALGORITHM"))

    refreshToken = jwt.encode({
      "sub" : user.email,
      "userId": user.id,
      "orgs" : orgs,
      "exp" : refreshTokenExpires
    }, Config.getValByKey("SECRET_KEY"), Config.getValByKey("ALGORITHM"))
    
    return Token(accessToken=accessToken,refreshToken=refreshToken)

  


file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\bucket\model\Bucket.py
from sqlmodel import Field, SQLModel
from sqlalchemy import Column, DateTime, func
from datetime import datetime
from typing import Optional

class Bucket(SQLModel, table=True):
  id: int = Field(default=None, primary_key=True)
  expId: int = Field(default=None, nullable=True)
  endUserId: int = Field(default=None, nullable=True)
  variationId: int = Field(default=None, nullable=True)
  createdAt: Optional[datetime] = Field(
    sa_column=Column(
      DateTime(timezone=True), server_default=func.now(), nullable=True
    )
  )
  updatedAt: Optional[datetime] = Field(
    sa_column=Column(
      DateTime(timezone=True), onupdate=func.now(), nullable=True
    )
  )

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\bucket\repository\BucketRepository.py
from abc import ABC, abstractmethod
from src.bucket.model.Bucket import Bucket

class BucketRepository(ABC):
  
  @abstractmethod
  def get(self, experimentId: int, endUserId: int) -> Bucket | None:
    pass

  @abstractmethod
  def add(self, bucket: Bucket) -> Bucket:
    pass

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\bucket\repository\BucketRepositoryImp.py
from src.bucket.repository.BucketRepository import BucketRepository
from src.bucket.model.Bucket import Bucket
from db import DBSessionDep
from sqlalchemy.exc import IntegrityError
from sqlmodel import select

class BucketRepositoryImp(BucketRepository):
  def __init__(self, db: DBSessionDep):
    self.db = db

  def get(self, experimentId: int, endUserId: int) -> Bucket | None:
    return self.db.exec(
      select(Bucket)
      .where(Bucket.expId == experimentId)
      .where(Bucket.endUserId == endUserId)
    ).first()

  def add(self, bucket: Bucket) -> Bucket:
    try:
      self.db.add(bucket)
      self.db.commit()
      self.db.refresh(bucket)
      return bucket
    except IntegrityError:
      # If we hit a Unique Constraint error (Duplicate), 
      # it means another request just saved it.
      # We rollback the failed transaction and return the existing one.
      self.db.rollback()
      existing = self.get(bucket.expId, bucket.endUserId)
      return existing

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\condition\ConditionRouter.py
from fastapi import APIRouter
from di import ConditionServiceDep
from src.condition.dtos.ConditionCreateRequestDto import ConditionCreateRequestDto
from src.condition.dtos.ConditionResponseDto import ConditionResponseDto

routes = APIRouter()

@routes.post(
  "/experiments/{experimentId}/conditions", 
  response_model=ConditionResponseDto, 
  tags=["condition"],
  name="act:create-condition"
)
async def createCondition(
    experimentId: int,
    reqDto: ConditionCreateRequestDto,
    service: ConditionServiceDep
  ) -> ConditionResponseDto:
  return service.createCondition(experimentId, reqDto)

@routes.get(
  "/experiments/{experimentId}/conditions", 
  response_model=list[ConditionResponseDto], 
  tags=["condition"],
  name="act:get-conditions"
)
async def getConditions(
    experimentId: int,
    service: ConditionServiceDep
  ) -> list[ConditionResponseDto]:
  return service.getConditions(experimentId)

@routes.delete(
  "/conditions/{id}", 
  response_model=ConditionResponseDto, 
  tags=["condition"],
  name="act:delete-condition"
)
async def deleteCondition(
    id: int,
    service: ConditionServiceDep
  ) -> ConditionResponseDto:
  return service.deleteCondition(id)

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\condition\dtos\ConditionCreateRequestDto.py
from typing import List
from pydantic import BaseModel, field_validator, HttpUrl, TypeAdapter, ValidationError
from src.condition.model.Operator import Operator

class ConditionCreateRequestDto(BaseModel):
  urls: List[str]
  operator: Operator

  @field_validator('urls')
  def validate_urls(cls, v):
    if not v:
      raise ValueError("The list of URLs cannot be empty!")

    for url in v:
      try:
        TypeAdapter(HttpUrl).validate_python(url)
      except ValidationError:
        raise ValueError(f"Invalid URL format: {url}!")
    return v

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\condition\dtos\ConditionResponseDto.py
from dataclasses import dataclass
from typing import List
from src.condition.model.Operator import Operator

@dataclass
class ConditionResponseDto:
  id: int
  experimentId: int
  urls: List[str]
  operator: Operator

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\condition\model\Condition.py
from sqlmodel import Field, SQLModel, ARRAY, String, Relationship
from typing import Optional, List
from pydantic import HttpUrl
from sqlalchemy import Column, DateTime, func
from datetime import datetime

from src.condition.model.Operator import Operator

class Condition(SQLModel, table=True):
  id: int = Field(default=None, primary_key=True)
  urls: List[HttpUrl] = Field(sa_column=Column(ARRAY(String), nullable=True))
  operator: Operator = Field(default=Operator.CONTAIN)
  experiment: Optional["Experiment"] = Relationship(back_populates="conditions") # type: ignore
  experimentId: Optional[int] = Field(default=None, foreign_key="experiment.id")
  createdAt: Optional[datetime] = Field(
    sa_column=Column(
      DateTime(timezone=True), server_default=func.now(), nullable=True
    )
  )
  updatedAt: Optional[datetime] = Field(
    sa_column=Column(
      DateTime(timezone=True), onupdate=func.now(), nullable=True
    )
  )

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\condition\model\Operator.py
from enum import StrEnum

class Operator(StrEnum):
  NOT_CONTAIN = "NOT CONTAIN"
  CONTAIN = "CONTAIN"
  IS = "IS"
  IS_NOT = "IS_NOT"

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\condition\repository\ConditionRepository.py
from abc import ABC, abstractmethod
from src.condition.model.Condition import Condition

class ConditionRepository(ABC):
  
  @abstractmethod
  def add(self, condition: Condition) -> Condition:
    pass

  @abstractmethod
  def getByExperimentId(self, experimentId: int) -> list[Condition]:
    pass

  @abstractmethod
  def getById(self, id: int) -> Condition:
    pass

  @abstractmethod
  def delete(self, condition: Condition):
    pass

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\condition\repository\ConditionRepositoryImp.py
from src.condition.repository.ConditionRepository import ConditionRepository
from src.condition.model.Condition import Condition
from db import DBSessionDep
from sqlmodel import select
from fastapi import status, HTTPException

class ConditionRepositoryImp(ConditionRepository):
  def __init__(self, db: DBSessionDep):
    self.db = db

  def add(self, condition: Condition) -> Condition:
    self.db.add(condition)
    self.db.commit()
    self.db.refresh(condition)
    return condition

  def getByExperimentId(self, experimentId: int) -> list[Condition]:
    return self.db.exec(
      select(Condition).where(Condition.experimentId == experimentId)
    ).all()

  def getById(self, id: int) -> Condition:
    condition = self.db.get(Condition, id)
    if not condition:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Condition not found")
    return condition

  def delete(self, condition: Condition):
    self.db.delete(condition)
    self.db.commit()

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\condition\services\ConditionService.py
from src.condition.repository.ConditionRepository import ConditionRepository
from src.experiment.repository.ExperimentRepository import ExperimentRepository
from src.condition.dtos.ConditionCreateRequestDto import ConditionCreateRequestDto
from src.condition.dtos.ConditionResponseDto import ConditionResponseDto
from src.condition.model.Condition import Condition
from src.utils.CacheService import CacheService
from fastapi import HTTPException, status

class ConditionService:
  def __init__(
    self, 
    repo: ConditionRepository,
    experimentRepo: ExperimentRepository,
    cacheService: CacheService
  ):
    self.repo = repo
    self.experimentRepo = experimentRepo
    self.cache = cacheService

  def createCondition(
      self, 
      experimentId: int, 
      reqDto: ConditionCreateRequestDto
    ) -> ConditionResponseDto:
    # Check if experiment exists
    experiment = self.experimentRepo.getById(experimentId)
    if not experiment:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Experiment not found")

    newCondition = Condition(
      experimentId=experimentId,
      operator=reqDto.operator,
      urls=reqDto.urls
    )
    
    savedCondition = self.repo.add(newCondition)
    
    # 3. INVALIDATE CACHE
    # The targeting rules have changed. We must clear the cache for this project.
    self.invalidateProjectCache(experiment.projectId)
    
    return self.mapToResponse(savedCondition)

  def deleteCondition(self, id: int) -> ConditionResponseDto:
    condition = self.repo.getById(id)
    if not condition:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Condition not found!")
        
    # We need the experiment to find the projectId
    experiment = self.experimentRepo.getById(condition.experimentId)
    
    self.repo.delete(condition)
    
    # 3. INVALIDATE CACHE
    if experiment:
      self.invalidateProjectCache(experiment.projectId)
        
    return self.mapToResponse(condition)

  # Helper to keep code clean
  def invalidateProjectCache(self, projectId: int):
    cacheKey = f"project:{projectId}:active-experiments"
    self.cache.delete(cacheKey)

  def mapToResponse(self, c: Condition) -> ConditionResponseDto:
    return ConditionResponseDto(
      id=c.id,
      experimentId=c.experimentId,
      urls=c.urls,
      operator=c.operator
    )
  
  def getConditions(self, experimentId: int) -> list[ConditionResponseDto]:
    self.experimentRepo.getById(experimentId)
    conditions = self.repo.getByExperimentId(experimentId)
    return [self.mapToResponse(c) for c in conditions]

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\db\links\PermissionType.py
from enum import StrEnum

class PermissionType(StrEnum):
  OWNER = "Owner"
  EDITOR = "Editor"
  VIEWER = "Viewer"

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\db\links\UserOrgLink.py
from sqlmodel import Field, SQLModel, Relationship
from typing import Optional

class UserOrgLink(SQLModel, table=True):
  userId: int | None = Field(default=None, foreign_key="userinfo.id", primary_key=True)
  orgId: int | None = Field(default=None, foreign_key="organization.id", primary_key=True)
  
  # 1. Added Role Foreign Key AND Relationship
  roleId: int | None = Field(default=None, foreign_key="role.id")
  role: Optional["Role"] = Relationship(back_populates="userOrgLinks") # type: ignore 

  # 2. Added MenuTemplate Foreign Key AND Relationship
  menuTemplateId: int | None = Field(default=None, foreign_key="menutemplate.id")
  menuTemplate: Optional["MenuTemplate"] = Relationship(back_populates="userOrgLinks") # type: ignore 

  disabled: bool = Field(default=True , nullable=False)
  super: bool = Field(default=False , nullable=False)

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\db\links\UserProjectLink.py
from sqlmodel import Field, SQLModel
from src.db.links.PermissionType import PermissionType


class UserProjectLink(SQLModel, table=True):
  userId: int | None = Field(default=None, foreign_key="userinfo.id", primary_key=True)
  projectId: int | None = Field(default=None, foreign_key="project.id", primary_key=True)
  disabled: bool = Field(default=False, nullable=False)
  super: bool = Field(default=False, nullable=False)
  permissionType: PermissionType = Field(default=PermissionType.VIEWER)

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\db\repository\UserOrgLinkRepository.py
from abc import ABC, abstractmethod
from src.db.links.UserOrgLink import UserOrgLink

class UserOrgLinkRepository(ABC):
  @abstractmethod
  def edit(self, userOrgLink: UserOrgLink) -> UserOrgLink|None:
    pass

  @abstractmethod
  def get(self, userId: int, orgId: int) -> UserOrgLink:
    pass

  @abstractmethod
  def getSuperAdminsByOrgId(self, orgId: int) -> list[UserOrgLink]:
    pass

  @abstractmethod
  def add(self, link: UserOrgLink) -> UserOrgLink:
    pass

  @abstractmethod
  def getActiveOrgs(self, userId: int, orgId: int) -> UserOrgLink:
    pass



file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\db\repository\UserOrgLinkRepositoryImp.py
from src.db.repository.UserOrgLinkRepository import UserOrgLinkRepository
from src.db.links.UserOrgLink import UserOrgLink
from db import DBSessionDep
from sqlmodel import select

class UserOrgLinkRepositoryImp(UserOrgLinkRepository):
  def __init__(self, db: DBSessionDep):
    self.db = db

  def get(self, userId: int, orgId: int) -> UserOrgLink|None:
    return self.db.exec(select(UserOrgLink).filter_by(userId=userId,orgId=orgId)).first()

  def edit(self, userOrgLink: UserOrgLink) -> UserOrgLink:    

    self.db.add(userOrgLink)
    self.db.commit()
    self.db.refresh(userOrgLink)

    return userOrgLink
  
  def getSuperAdminsByOrgId(self, orgId: int) -> list[UserOrgLink]:
    return self.db.exec(
      select(UserOrgLink)
      .where(UserOrgLink.orgId == orgId)
      .where(UserOrgLink.super == True)
    ).all()
  
  def add(self, link: UserOrgLink) -> UserOrgLink:
    self.db.add(link)
    self.db.commit()
    self.db.refresh(link)
    return link
  
  def getActiveOrgs(self, userId: int, orgId: int) -> list[UserOrgLink]:
    return self.db.exec(
      select(UserOrgLink)
      .where(UserOrgLink.orgId == orgId)
      .where(UserOrgLink.disabled == False)
      .where(UserOrgLink.userId == userId)
    ).all()



  

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\db\repository\UserProjectLinkRepository.py
from abc import ABC, abstractmethod
from src.db.links.UserProjectLink import UserProjectLink
from src.project.model.Project import Project

class UserProjectLinkRepository(ABC):
  @abstractmethod
  def add(self, link: UserProjectLink) -> UserProjectLink:
    pass

  @abstractmethod
  def get(self, userId: int, projectId: int) -> UserProjectLink | None:
    pass

  @abstractmethod
  def delete(self, link: UserProjectLink):
    pass

  @abstractmethod
  def getActiveProjectsByOrgIds(self, userId: int, activeOrgIds: list[int]) -> list[Project]:
    pass

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\db\repository\UserProjectLinkRepositoryImp.py
from src.db.repository.UserProjectLinkRepository import UserProjectLinkRepository
from src.db.links.UserProjectLink import UserProjectLink
from db import DBSessionDep
from sqlmodel import select, col
from src.project.model.Project import Project

class UserProjectLinkRepositoryImp(UserProjectLinkRepository):
  def __init__(self, db: DBSessionDep):
    self.db = db

  def add(self, link: UserProjectLink) -> UserProjectLink:
    self.db.add(link)
    self.db.commit()
    self.db.refresh(link)
    return link

  def get(self, userId: int, projectId: int) -> UserProjectLink | None:
    return self.db.exec(
      select(UserProjectLink)
      .where(UserProjectLink.userId == userId)
      .where(UserProjectLink.projectId == projectId)
    ).first()
  
  def delete(self, link: UserProjectLink):
    self.db.delete(link)
    self.db.commit()

  def getActiveProjectsByOrgIds(self, userId: int, activeOrgIds: list[int]) -> list[Project]:
    # If there are no active orgs, the user cannot have any valid projects
    if not activeOrgIds:
      return []

    return self.db.exec(
      select(Project)
      .join(UserProjectLink, Project.id == UserProjectLink.projectId)
      .where(UserProjectLink.userId == userId)       # Link belongs to user
      .where(UserProjectLink.disabled == False)      # Link is enabled
      .where(col(Project.orgId).in_(activeOrgIds))   # Project belongs to an active Org
    ).all()

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\decision\DecisionRouter.py
from fastapi import APIRouter, Response, BackgroundTasks
from di import DecisionServiceDep
from src.decision.dtos.DecisionRequestDto import DecisionRequestDto
from src.decision.dtos.DecisionResponseDto import DecisionResponseDto

routes = APIRouter()

@routes.post(
  "/decision", 
  tags=["decision"],
  name="act:make-decision",
  response_model=DecisionResponseDto
)
async def makeDecision(
  reqDto: DecisionRequestDto, 
  decisionService: DecisionServiceDep,
  response: Response,
  bgTasks: BackgroundTasks # Change: Inject BackgroundTasks
) -> DecisionResponseDto:

  # Pass bgTasks to service
  decisionRes: DecisionResponseDto = decisionService.makeDecision(reqDto, bgTasks)
  return decisionRes

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\decision\dtos\DecisionRequestDto.py
from dataclasses import dataclass
from typing import Optional

@dataclass
class DecisionRequestDto:
  url: str # Required
  projectId: int # Required
  endUserId: Optional[int] = None
                     

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\decision\dtos\DecisionResponseDto.py
from dataclasses import dataclass
from typing import List, Optional
from src.condition.dtos.ConditionResponseDto import ConditionResponseDto
from src.metrics.dtos.MetricsResponseDto import MetricsResponseDto

@dataclass
class VariationDecisionDto:
  variationId: int
  variationTitle: str
  js: Optional[str]
  css: Optional[str]

@dataclass
class ExperimentDecisionDto:
  experimentId: int
  experimentTitle: str
  experimentJs: Optional[str]
  experimentCss: Optional[str]
  variation: VariationDecisionDto
  conditions: List[ConditionResponseDto]
  metrics: List[MetricsResponseDto]

@dataclass
class DecisionResponseDto:
  endUserId: int
  decisions: List[ExperimentDecisionDto]

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\decision\services\DecisionService.py
import mmh3 # type: ignore
import random
from fastapi import BackgroundTasks
from src.bucket.repository.BucketRepository import BucketRepository
from src.experiment.repository.ExperimentRepository import ExperimentRepository
from src.decision.dtos.DecisionRequestDto import DecisionRequestDto
from src.decision.dtos.DecisionResponseDto import DecisionResponseDto, ExperimentDecisionDto, VariationDecisionDto
from src.bucket.model.Bucket import Bucket
from src.experiment.model.Experiment import Experiment
from src.experiment.model.ExperimentStatus import ExperimentStatus
from src.condition.model.Operator import Operator
from src.metrics.dtos.MetricsResponseDto import MetricsResponseDto
from src.condition.dtos.ConditionResponseDto import ConditionResponseDto
from src.utils.CacheService import CacheService
from src.variation.model.Variation import Variation
from src.condition.model.Condition import Condition
from src.metrics.model.Metrics import Metrics
from config import Config

class DecisionService:
  # The bucketing scale (1 to 10,000 for 0.01% granularity)
  MAX_TRAFFIC_VAL = Config.getValByKey("MAX_TRAFFIC_VAL")

  def __init__(
    self, 
    bucketRepo: BucketRepository,
    experimentRepo: ExperimentRepository,
    cacheService: CacheService
  ):
    self.bucketRepo = bucketRepo
    self.experimentRepo = experimentRepo
    self.cache = cacheService

  def makeDecision(
      self, 
      reqDto: DecisionRequestDto,
      bgTasks: BackgroundTasks,
    ) -> DecisionResponseDto:
    
    projectId: int = reqDto.projectId
    
    # Identity Management
    endUserId = reqDto.endUserId if reqDto.endUserId else random.randint(100000, 999999)

    # Fetch Active Experiments (Redis Cache -> DB)
    activeExperiments = self.getActiveExperiments(projectId)

    decisions: list[ExperimentDecisionDto] = []

    for exp in activeExperiments:
      # Targeting Check
      isTargeted : bool = self.checkTargeting(exp, reqDto.url)
      if not isTargeted:
        continue

      # Consistency Check (Sticky Bucketing)
      existingBucket = self.bucketRepo.get(experimentId=exp.id, endUserId=endUserId)

      if existingBucket:
        # User is already locked in. Return the saved variation.
        assignedVariation = next((v for v in exp.variations if v.id == existingBucket.variationId), None)
        if assignedVariation:
          decisions.append(self.buildDecisionDto(exp, assignedVariation))
      
      else:
        # The Bucketing Machine
        hashKey = f"{endUserId}:{exp.id}"
        hashInt = mmh3.hash(hashKey)
        
        # Scale hash to 1 - 10,000
        bucketVal = (abs(hashInt) % int(self.MAX_TRAFFIC_VAL)) + 1
        
        # Traffic Allocation
        chosenVariation = None
        cumulativeTraffic = 0

        if len(exp.variations) == 1:
          chosenVariation = exp.variations[0]
        else:   
          for variation in exp.variations:
            rangeLimit = int(variation.traffic * 100)
            
            if bucketVal <= (cumulativeTraffic + rangeLimit):
              chosenVariation = variation
              break
          
          cumulativeTraffic += rangeLimit

        if chosenVariation:
          # Async Persistence
          bgTasks.add_task(self.recordAssignment, exp.id, endUserId, chosenVariation.id)
          decisions.append(self.buildDecisionDto(exp, chosenVariation))

    return DecisionResponseDto(endUserId=endUserId, decisions=decisions)

  def recordAssignment(self, expId: int, userId: int, varId: int):
    # Runs in background. Checks for duplicates before inserting.
    existing = self.bucketRepo.get(expId, userId)
    if not existing:
      self.bucketRepo.add(Bucket(expId=expId, endUserId=userId, variationId=varId))

  def checkTargeting(self, exp: Experiment, reqUrl: str) -> bool:
    if exp.url == reqUrl:
      return True

    if not exp.conditions:
      return True

    matches = []
    for cond in exp.conditions:
      isMatch = False 
      
      if cond.operator in [Operator.IS, Operator.CONTAIN]:
        for condUrl in cond.urls:
          if cond.operator == Operator.CONTAIN and reqUrl in condUrl:
            isMatch = True
            break
          if cond.operator == Operator.IS and reqUrl in condUrl:
            isMatch = True
            break
             
      elif cond.operator in [Operator.IS_NOT, Operator.NOT_CONTAIN]:
        isMatch = True 
        for condUrl in cond.urls:
          if cond.operator == Operator.NOT_CONTAIN and reqUrl in condUrl:
            isMatch = False
            break 
          if cond.operator == Operator.IS_NOT and reqUrl in condUrl:
            isMatch = False
            break 
      
      matches.append(isMatch)

    if exp.conditionType == "ALL":
      return all(matches)
    else: # ANY
      return any(matches)

  def getActiveExperiments(self, projectId: int) -> list[Experiment]:
    cacheKey = f"project:{projectId}:active-experiments"
    
    # Try Redis Cache
    cachedData = self.cache.get(cacheKey)
    if cachedData:
      return [self.deserializeExperiment(item) for item in cachedData]
    
    # Cache Miss: Fetch from DB
    allExperiments = self.experimentRepo.getAll(rows=1000, page=1, projectId=projectId)
    activeExperiments = [e for e in allExperiments if e.status == ExperimentStatus.ACTIVE]

    # Serialize and Save to Redis
    serializedData = [self.serializeExperiment(e) for e in activeExperiments]
    self.cache.set(cacheKey, serializedData)
    
    return activeExperiments

  # Helper: Convert DB Object to Dictionary for Redis
  def serializeExperiment(self, exp: Experiment) -> dict:
    return {
      "id": exp.id,
      "title": exp.title,
      "status": exp.status,
      "js": exp.js,
      "css": exp.css,
      "conditionType": exp.conditionType,
      "conditions": [c.model_dump() for c in exp.conditions],
      "metrics": [m.model_dump() for m in exp.metrics],
      "variations": [v.model_dump() for v in exp.variations]
    }

  # Helper: Convert Dictionary back to DB Object
  def deserializeExperiment(self, data: dict) -> Experiment:
    # Pop the nested lists out of the dictionary
    conditionsData = data.pop("conditions", [])
    metricsData = data.pop("metrics", [])
    variationsData = data.pop("variations", [])

    # Create the Experiment object with only the simple fields (id, title, etc.)
    exp = Experiment(**data)

    # Manually reconstruct the relationships from the popped data
    exp.conditions = [Condition(**c) for c in conditionsData]
    exp.metrics = [Metrics(**m) for m in metricsData]
    exp.variations = [Variation(**v) for v in variationsData]
    
    return exp

  def buildDecisionDto(self, exp: Experiment, variation) -> ExperimentDecisionDto:
    condDtos = [
      ConditionResponseDto(
        id=c.id, 
        experimentId=c.experimentId, 
        urls=[str(u) for u in c.urls], 
        operator=c.operator
      ) for c in exp.conditions
    ]
    
    metDtos = [
      MetricsResponseDto(
        id=m.id, 
        experimentId=m.experimentId, 
        title=m.title, 
        custom=m.custom, 
        selector=m.selector, 
        description=m.description, 
        triggeredOnQA=m.triggeredOnQA,
        triggeredOnLIVE=m.triggeredOnLIVE
      ) for m in exp.metrics
    ]

    return ExperimentDecisionDto(
      experimentId=exp.id,
      experimentTitle=exp.title,
      experimentJs=exp.js,
      experimentCss=exp.css,
      variation=VariationDecisionDto(
        variationId=variation.id,
        variationTitle=variation.title,
        js=variation.js,
        css=variation.css
      ),
      conditions=condDtos,
      metrics=metDtos
    )

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\email\EmailService.py
import smtplib
from abc import ABC, abstractmethod

class EmailService(ABC):
  
  @abstractmethod
  def sendAccountVerificationOtp(email: str, otp: str) -> bool:
    pass

  @abstractmethod
  def sendForgotPasswordOtp(email: str, otp: str) -> bool:
    pass

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\email\EmailServiceImp.py
import smtplib
from src.email.EmailService import EmailService
from fastapi import BackgroundTasks
from config import Config
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

class EmailServiceImp(EmailService):
  host: str = Config.getValByKey("HOST")
  port: int = int(Config.getValByKey("PORT"))
  username: str = Config.getValByKey("UNAME")
  password: str = Config.getValByKey("PASSWORD")
  sender: str = Config.getValByKey("SENDER")

  def __init__(self, bgTask: BackgroundTasks):
    self.bgTask = bgTask

  def sendMail(self, email: str, html: str, subject: str):
    message = MIMEMultipart("alternative")
    message["Subject"] = subject
    message["From"] = self.sender
    message["To"] = email

    part = MIMEText(html, "html")
    message.attach(part)

    try:
      # 1. Initialize connection (Plain SMTP)
      server = smtplib.SMTP(self.host, self.port)
      server.set_debuglevel(1)
      
      # 2. Identify ourselves to the server
      server.ehlo()

      # NOTE: Do NOT call server.starttls() because the server reported it is not supported.
      # NOTE: Do NOT manually set server.esmtp_features. Let smtplib handle it.
      
      # 3. Login
      # Python will automatically choose the best auth method (PLAIN, LOGIN, etc.)
      server.login(self.username, self.password)
      
      # 4. Send
      server.sendmail(self.sender, email, message.as_string())
    except Exception as e:
        print(f"Failed to send email: {e}")
    finally:
      try:
          server.quit()
      except:
          pass
  
  def sendAccountVerificationOtp(self, email: str, otp: str) -> bool:
    html : str = f"""
      <html>
        <body>
          <p>Please use this otp: {otp} to verify you account!</p>
        </body>
      </html>
    """

    self.bgTask.add_task(self.sendMail, email, html, "Account verification otp!")
    return True
  
  def sendForgotPasswordOtp(self, email: str, otp: str) -> bool:
    html : str = f"""
      <html>
        <body>
          <p>Please use this otp: {otp} to reset you password!</p>
        </body>
      </html>
    """

    self.bgTask.add_task(self.sendMail, email, html, "Password reset otp!")
    return True

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\experiment\ExperimentRouter.py
from fastapi import APIRouter
from di import ExperimentServiceDep
from src.experiment.dtos.ExperimentCreateRequestDto import ExperimentCreateRequestDto
from src.experiment.dtos.ExperimentCreateResponseDto import ExperimentCreateResponseDto
from src.experiment.dtos.ExperimentResponseDto import ExperimentResponseDto
from src.utils.pagination.PaginationRequestDto import PaginationRequestDto
from src.utils.pagination.PaginationResponseDto import PaginationResponseDto
from src.experiment.dtos.ExperimentUpdateRequestDto import ExperimentUpdateRequestDto

routes = APIRouter()

@routes.post(
  "/experiments", 
  response_model=ExperimentCreateResponseDto, 
  tags=["experiment"],
  name="act:create-experiment"
)
async def createExperiment(
    reqDto: ExperimentCreateRequestDto,
    service: ExperimentServiceDep
  ) -> ExperimentCreateResponseDto:
  return service.createExperiment(reqDto)

@routes.post(
  "/experiments/all",
  tags=["experiment"],
  name="act:get-experiments",
  response_model=PaginationResponseDto[ExperimentResponseDto]
)
async def getExperiments(
  reqDto: PaginationRequestDto, 
  service: ExperimentServiceDep
) -> PaginationResponseDto[ExperimentResponseDto]:  
  return service.getExperiments(reqDto)

@routes.get(
  "/experiments/{id}",
  tags=["experiment"],
  name="act:get-experiment",
  response_model=ExperimentResponseDto
)
async def getExperimentById(
  id: int,
  service: ExperimentServiceDep
) -> ExperimentResponseDto:
  return service.getById(id)

@routes.patch(
  "/experiments/{id}",
  tags=["experiment"],
  name="act:update-experiment",
  response_model=ExperimentResponseDto
)
async def updateExperiment(
  id: int,
  reqDto: ExperimentUpdateRequestDto,
  service: ExperimentServiceDep
) -> ExperimentResponseDto:
  """
  Update specific fields of an experiment (Title, Status, Traffic Allocation, etc.)
  """
  return service.updateExperiment(id, reqDto)


@routes.post(
  "/experiments-by-project-and-org",
  tags=["experiment"],
  name="act:experiments-by-project-and-org",
  response_model=PaginationResponseDto[ExperimentResponseDto]
)
async def getExperiments(
  reqDto: PaginationRequestDto, 
  service: ExperimentServiceDep
) -> PaginationResponseDto[ExperimentResponseDto]:  
  """
  Get experiments by Project ID (and Org ID for verification).
  Payload: { "orgId": 1, "projectId": 10, "rows": 10, "page": 1 }
  """
  return service.getExperimentsByProjectAndOrg(reqDto)

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\experiment\dtos\ExperimentCreateRequestDto.py
from dataclasses import dataclass
from typing import List, Optional
from pydantic import constr
from src.experiment.model.ExperimentType import ExperimentType
from src.experiment.model.ExperimentStatus import ExperimentStatus
from src.experiment.model.TriggerType import TriggerType
from src.experiment.model.ConditionType import ConditionType

@dataclass
class ExperimentCreateRequestDto:
  projectId: int
  title: constr(min_length=1) # type: ignore
  url: Optional[str] = None
  description: Optional[str] = None
  


file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\experiment\dtos\ExperimentCreateResponseDto.py
from dataclasses import dataclass
from src.experiment.model.ExperimentStatus import ExperimentStatus

@dataclass
class ExperimentCreateResponseDto:
  id: int
  title: str
  status: ExperimentStatus

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\experiment\dtos\ExperimentResponseDto.py
from dataclasses import dataclass
from typing import Optional
from datetime import datetime
from src.experiment.model.ExperimentType import ExperimentType
from src.experiment.model.ExperimentStatus import ExperimentStatus
from src.experiment.model.TriggerType import TriggerType
from src.experiment.model.ConditionType import ConditionType

@dataclass
class ExperimentResponseDto:
  id: int
  title: str
  projectId: int
  type: ExperimentType
  status: ExperimentStatus
  url: Optional[str]
  description: Optional[str]
  triggerType: TriggerType
  conditionType: ConditionType
  js: Optional[str]
  css: Optional[str]
  createdAt: Optional[datetime]
  updatedAt: Optional[datetime]

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\experiment\dtos\ExperimentUpdateRequestDto.py
from typing import Optional
from pydantic import model_validator, BaseModel, field_validator, HttpUrl, TypeAdapter, ValidationError
from src.experiment.model.ExperimentType import ExperimentType
from src.experiment.model.ExperimentStatus import ExperimentStatus
from src.experiment.model.TriggerType import TriggerType
from src.experiment.model.ConditionType import ConditionType

class ExperimentUpdateRequestDto(BaseModel):
  title: Optional[str] = None
  js: Optional[str] = None
  css: Optional[str] = None
  type: Optional[ExperimentType] = None
  status: Optional[ExperimentStatus] = None
  url: Optional[str] = None
  description: Optional[str] = None
  triggerType: Optional[TriggerType] = None
  conditionType: Optional[ConditionType] = None

  # 1. Validate URL format if provided
  @field_validator('url')
  def validate_url(cls, v):
    if v is not None:
      try:
        # We use Pydantic's TypeAdapter to validate the string as a HttpUrl
        TypeAdapter(HttpUrl).validate_python(v)
      except ValidationError:
        raise ValueError("Invalid URL format!")
    return v

  # 2. Existing validator to ensure at least one field is present
  @model_validator(mode='after')
  def check_at_least_one_field(self):
    # Check if all fields are None
    if not any(value is not None for value in self.__dict__.values()):
      raise ValueError("At least one field must be provided for update!")
    return self

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\experiment\model\ConditionType.py
from enum import StrEnum

class ConditionType(StrEnum):
  ALL = "ALL"
  ANY = "ANY"

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\experiment\model\Experiment.py
from sqlmodel import Field, SQLModel, Relationship
from sqlalchemy import Text, Column, DateTime, func
from typing import Optional
from datetime import datetime

from src.experiment.model.ConditionType import ConditionType
from src.experiment.model.TriggerType import TriggerType
from src.experiment.model.ExperimentType import ExperimentType
from src.experiment.model.ExperimentStatus import ExperimentStatus

class Experiment(SQLModel, table=True):
  id: int = Field(default=None, primary_key=True)
  js: str = Field(default=None, nullable=True, sa_type=Text)
  css: str = Field(default=None, nullable=True, sa_type=Text)
  url: str = Field(default=None, nullable=True)
  type: ExperimentType = Field(default=ExperimentType.AB_TEST)
  title: str = Field(default=None, nullable=True)
  status: ExperimentStatus = Field(default=ExperimentStatus.DRAFT)
  metrics: list["Metrics"] = Relationship(back_populates="experiment") # type: ignore
  conditions: list["Condition"] = Relationship(back_populates="experiment") # type: ignore
  variations: list["Variation"] = Relationship(back_populates="experiment") # type: ignore
  description: str = Field(default=None, nullable=True)
  triggerType: TriggerType = Field(default=TriggerType.IMMEDIATELY)
  conditionType: ConditionType = Field(default=ConditionType.ALL)
  project: Optional["Project"] = Relationship(back_populates="experiments") # type: ignore
  projectId: Optional[int] = Field(default=None, foreign_key="project.id")
  createdAt: Optional[datetime] = Field(
    sa_column=Column(
      DateTime(timezone=True), server_default=func.now(), nullable=True
    )
  )
  updatedAt: Optional[datetime] = Field(
    sa_column=Column(
      DateTime(timezone=True), onupdate=func.now(), nullable=True
    )
  )
  

  



file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\experiment\model\ExperimentStatus.py
from enum import StrEnum

class ExperimentStatus(StrEnum):
  DRAFT = "Draft"
  ACTIVE = "Active"
  PAUSED = "Paused"
  ARCHIVED = "Archived"
  ENDED = "Ended"

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\experiment\model\ExperimentType.py
from enum import StrEnum

class ExperimentType(StrEnum):
  AB_TEST = "AB Test"
  PERSONALIZATION = "Personalization"
  SPLIT_URL = "Split URL"
  REDIRECT = "Redirect"

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\experiment\model\TriggerType.py
from enum import StrEnum

class TriggerType(StrEnum):
  IMMEDIATELY = "Immediately"
  DOM_READY = "DOM Ready"
  URL_CHANGES = "URL Changes"

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\experiment\repository\ExperimentRepository.py
from abc import ABC, abstractmethod
from src.experiment.model.Experiment import Experiment

class ExperimentRepository(ABC):
  
  @abstractmethod
  def add(self, experiment: Experiment) -> Experiment:
    pass

  @abstractmethod
  def getById(self, id: int) -> Experiment:
    pass

  @abstractmethod
  def getAll(self, rows: int, page: int, projectId: int) -> list[Experiment]:
    pass

  @abstractmethod
  def countAll(self, projectId: int) -> int:
    pass

  @abstractmethod
  def edit(self, experiment: Experiment) -> Experiment:
    pass

  @abstractmethod
  def getAllActive(self, rows: int, page: int, projectId: int) -> list[Experiment]:
    pass

  @abstractmethod
  def getAllByProjectAndOrg(self, rows: int, page: int, projectId: int, orgId: int) -> list[Experiment]:
    pass
    
  @abstractmethod
  def countByProjectAndOrg(self, projectId: int, orgId: int) -> int:
    pass

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\experiment\repository\ExperimentRepositoryImp.py
from src.experiment.model.ExperimentStatus import ExperimentStatus
from src.experiment.repository.ExperimentRepository import ExperimentRepository
from src.experiment.model.Experiment import Experiment
from db import DBSessionDep
from fastapi import status, HTTPException
from sqlmodel import select
from sqlalchemy import func
from sqlalchemy.orm import selectinload
from src.project.model.Project import Project

class ExperimentRepositoryImp(ExperimentRepository):
  def __init__(self, db: DBSessionDep):
    self.db = db

  def add(self, experiment: Experiment) -> Experiment:
    self.db.add(experiment)
    self.db.commit()
    self.db.refresh(experiment)
    return experiment

  def getById(self, id: int) -> Experiment:
    experiment = self.db.get(Experiment, id)
    if not experiment:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Experiment not found")
    return experiment

  def getAll(self, rows: int, page: int, projectId: int) -> list[Experiment]:
    offset: int = (page - 1) * rows
    return self.db.exec(
      select(Experiment)
      .where(Experiment.projectId == projectId)
      .offset(offset).limit(rows)
    ).all()

  def countAll(self, projectId: int) -> int:
    return self.db.exec(
      select(func.count(Experiment.id))
      .where(Experiment.projectId == projectId)
    ).one()

  def edit(self, experiment: Experiment) -> Experiment:
    self.db.add(experiment)
    self.db.commit()
    self.db.refresh(experiment)
    return experiment
  
  def getAllActive(self, rows: int, page: int, projectId: int) -> list[Experiment]:
    offset: int = (page - 1) * rows
    return self.db.exec(
      select(Experiment)
      .where(Experiment.projectId == projectId)
      .where(Experiment.status == ExperimentStatus.ACTIVE)
      .options(
        selectinload(Experiment.conditions),
        selectinload(Experiment.variations),
        selectinload(Experiment.metrics)
      )
      .offset(offset).limit(rows)
    ).all()
  
  def getAllByProjectAndOrg(self, rows: int, page: int, projectId: int, orgId: int) -> list[Experiment]:
    offset: int = (page - 1) * rows
    return self.db.exec(
      select(Experiment)
      .join(Project, Experiment.projectId == Project.id)
      .where(Experiment.projectId == projectId)
      .where(Project.orgId == orgId)
      .offset(offset).limit(rows)
    ).all()

  def countByProjectAndOrg(self, projectId: int, orgId: int) -> int:
    return self.db.exec(
      select(func.count(Experiment.id))
      .join(Project, Experiment.projectId == Project.id)
      .where(Experiment.projectId == projectId)
      .where(Project.orgId == orgId)
    ).one()

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\experiment\services\ExperimentService.py
from src.experiment.model.ConditionType import ConditionType
from src.experiment.model.ExperimentStatus import ExperimentStatus
from src.experiment.model.TriggerType import TriggerType
from src.experiment.model.ExperimentType import ExperimentType
from src.experiment.repository.ExperimentRepository import ExperimentRepository
from src.project.repository.ProjectRepository import ProjectRepository
from src.experiment.dtos.ExperimentCreateRequestDto import ExperimentCreateRequestDto
from src.experiment.dtos.ExperimentCreateResponseDto import ExperimentCreateResponseDto
from src.experiment.dtos.ExperimentResponseDto import ExperimentResponseDto
from src.experiment.dtos.ExperimentUpdateRequestDto import ExperimentUpdateRequestDto
from src.experiment.model.Experiment import Experiment
from src.variation.model.Variation import Variation
from src.utils.pagination.PaginationRequestDto import PaginationRequestDto
from src.utils.pagination.PaginationResponseDto import PaginationResponseDto
from fastapi import HTTPException, status

class ExperimentService:
  def __init__(
    self, 
    repo: ExperimentRepository, 
    projectRepo: ProjectRepository
  ):
    self.repo = repo
    self.projectRepo = projectRepo

  def createExperiment(self, reqDto: ExperimentCreateRequestDto) -> ExperimentCreateResponseDto:
    self.projectRepo.getProjectById(reqDto.projectId)

    newExp = Experiment(
      title=reqDto.title,
      projectId=reqDto.projectId,
      type=ExperimentType.AB_TEST,
      url=reqDto.url,
      status=ExperimentStatus.DRAFT,
      triggerType=TriggerType.IMMEDIATELY,
      conditionType=ConditionType.ALL,
      description=reqDto.description,
      js="",
      css="",
      variations=[],
      conditions=[], 
      metrics=[]     
    )

    newExp.variations.append(Variation(
      title="Control", 
      traffic=100,
      js=None,  
      css=None,
      isControl=True
    ))

    savedExp = self.repo.add(newExp)

    return ExperimentCreateResponseDto(
      id=savedExp.id,
      title=savedExp.title,
      status=savedExp.status
    )

  def getExperiments(self, reqDto: PaginationRequestDto) -> PaginationResponseDto[ExperimentResponseDto]:
    projectId = reqDto.orgId 
    
    total = reqDto.total
    if total is None or total == 0:
      total = self.repo.countAll(projectId=projectId)

    exps = self.repo.getAll(rows=reqDto.rows, page=reqDto.page, projectId=projectId)
    
    items = []
    for e in exps:
      items.append(self._mapToResponse(e))

    return PaginationResponseDto[ExperimentResponseDto](items=items, total=total)

  def getById(self, id: int) -> ExperimentResponseDto:
    e = self.repo.getById(id)
    return self._mapToResponse(e)

  # 1. Added update logic
  def updateExperiment(
      self, 
      id: int, 
      reqDto: ExperimentUpdateRequestDto
    ) -> ExperimentResponseDto:
    # Fetch existing experiment
    experiment = self.repo.getById(id)

    # Update fields if provided
    if reqDto.title is not None:
      experiment.title = reqDto.title
    if reqDto.js is not None:
      experiment.js = reqDto.js
    if reqDto.css is not None:
      experiment.css = reqDto.css
    if reqDto.type is not None:
      experiment.type = reqDto.type
    if reqDto.status is not None:
      experiment.status = reqDto.status
    if reqDto.url is not None:
      experiment.url = reqDto.url
    if reqDto.description is not None:
      experiment.description = reqDto.description
    if reqDto.triggerType is not None:
      experiment.triggerType = reqDto.triggerType
    if reqDto.conditionType is not None:
      experiment.conditionType = reqDto.conditionType

    updatedExp = self.repo.edit(experiment)
    return self._mapToResponse(updatedExp)

  # Helper to avoid code duplication in mapping
  def _mapToResponse(self, e: Experiment) -> ExperimentResponseDto:
    return ExperimentResponseDto(
      id=e.id,
      title=e.title,
      projectId=e.projectId, # type: ignore
      type=e.type,
      status=e.status,
      url=e.url,
      description=e.description,
      triggerType=e.triggerType,
      conditionType=e.conditionType,
      js=e.js,
      css=e.css,
      createdAt=e.createdAt,
      updatedAt=e.updatedAt
    )
  
  def getExperimentsByProjectAndOrg(self, reqDto: PaginationRequestDto) -> PaginationResponseDto[ExperimentResponseDto]:
    # 1. Defensive: Ensure projectId exists
    if not reqDto.projectId:
       # Fallback or Error depending on your preference. 
       # Here we assume strict mode as requested previously.
       raise HTTPException(status_code=400, detail="Project ID is required!")

    targetProjectId = reqDto.projectId
    targetOrgId = reqDto.orgId

    # 2. Handle Total Count (Using new Repo method)
    total = reqDto.total
    if total is None or total == 0:
      total = self.repo.countByProjectAndOrg(projectId=targetProjectId, orgId=targetOrgId)

    # 3. Fetch Data (Using new Repo method)
    # This automatically filters out experiments if the project doesn't belong to the org
    exps = self.repo.getAllByProjectAndOrg(
      rows=reqDto.rows, 
      page=reqDto.page, 
      projectId=targetProjectId,
      orgId=targetOrgId
    )
    
    # 4. Map to Response
    items = []
    for e in exps:
      items.append(self._mapToResponse(e))

    return PaginationResponseDto[ExperimentResponseDto](items=items, total=total)

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\menu\MenuRouter.py
from fastapi import APIRouter
from src.menu.dtos.MenuCreateRequestDto import MenuCreateRequestDto
from src.menu.dtos.MenuCreateResponseDto import MenuCreateResponseDto
from src.menu.dtos.MenuResponseDto import MenuResponseDto
from di import MenuServiceDep

routes = APIRouter()

@routes.post(
  "/menus/", 
  response_model= MenuCreateResponseDto, 
  tags=["menu"],
  name="act:create-menu"
)
async def createMenu(
    reqDto: MenuCreateRequestDto,
    menuService: MenuServiceDep
  )->MenuCreateResponseDto:  
  return menuService.createMenu(reqDto)

@routes.post(
  "/menus/all",
  tags=["menu"],
  name="act:get-menus",
  response_model=list[MenuResponseDto]
)
async def getMenus(
  menuService: MenuServiceDep
) -> list[MenuResponseDto]:  
  return menuService.getMenus()

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\menu\dtos\MenuCreateRequestDto.py
from dataclasses import dataclass
from pydantic import constr

@dataclass
class MenuCreateRequestDto:
  label: constr(min_length=1) # type: ignore
  icon: constr(min_length=1) # type: ignore
  href: constr(min_length=1) # type: ignore


file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\menu\dtos\MenuCreateResponseDto.py
from dataclasses import dataclass

@dataclass
class MenuCreateResponseDto:
  id: int
  label: str
  icon: str
  href: str

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\menu\dtos\MenuResponseDto.py
from dataclasses import dataclass

@dataclass
class MenuResponseDto:
  id: int
  label: str
  icon: str
  href: str

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\menu\model\Menu.py
from sqlmodel import Field, SQLModel

class Menu(SQLModel, table=True):
  id: int = Field(default=None, primary_key=True)
  label: str = Field(default=None, index=True, nullable=True)
  icon:  str = Field(default=None, nullable=True)
  href: str = Field(default=None, nullable=True)


    


file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\menu\repository\MenuRepository.py
from abc import ABC, abstractmethod
from src.menu.model.Menu import Menu

class MenuRepository(ABC):
  @abstractmethod
  def getMenuById(self, id: int) -> Menu:
    pass

  @abstractmethod
  def add(self, menu: Menu) -> Menu:
    pass

  @abstractmethod
  def getAllMenu(self) -> list[Menu]:
    pass

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\menu\repository\MenuRepositoryImp.py
from src.menu.repository.MenuRepository import MenuRepository
from src.menu.model.Menu import Menu
from db import DBSessionDep
from fastapi import status, HTTPException
from sqlmodel import select

class MenuRepositoryImp(MenuRepository):
  def __init__(self, db: DBSessionDep):
    self.db = db

  def getMenuById(self, id: int) -> Menu:
    menu = self.db.get(Menu,id)

    if not menu:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Menu not found")
    
    return menu

  def add(self, menu: Menu) -> Menu:
    existMenu = self.db.exec(select(Menu).filter_by(label=menu.label)).first()

    if existMenu:
      raise HTTPException(status_code=status.HTTP_302_FOUND, detail="Menu already exist by this name!")
    
    self.db.add(menu)
    self.db.commit()
    self.db.refresh(menu)

    return menu

  def getAllMenu(self) -> list[Menu]:
    return self.db.exec(select(Menu)).all()


  

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\menu\services\MenuService.py
from src.menu.repository.MenuRepository import MenuRepository
from src.menu.dtos.MenuCreateRequestDto import MenuCreateRequestDto
from src.menu.dtos.MenuCreateResponseDto import MenuCreateResponseDto
from src.menu.model.Menu import Menu;
from src.menu.dtos.MenuResponseDto import MenuResponseDto

class MenuService:
  def __init__(self, menuRepository : MenuRepository):
    self.repo = menuRepository

  def createMenu(self, reqDto: MenuCreateRequestDto) -> MenuCreateResponseDto:
    newMenu = self.repo.add(Menu(label=reqDto.label, icon=reqDto.icon, href=reqDto.href))
    resMenu = MenuCreateResponseDto(
      id=newMenu.id, 
      label=newMenu.label, 
      icon=newMenu.icon, 
      href=newMenu.href
    )
    return resMenu
  
  def getMenus(self)-> list[MenuResponseDto]:
    menuResponseDtoList: list[MenuResponseDto] = []
    menus: list[Menu] = self.repo.getAllMenu()

    for m in menus:
      menuDto: MenuResponseDto = MenuResponseDto(
        id=m.id,
        label=m.label, 
        icon=m.icon, 
        href=m.href
      )

      menuResponseDtoList.append(menuDto)

    return menuResponseDtoList



file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\menutemplate\MenuTemplateRouter.py
from typing import Any, List
from fastapi import APIRouter
from src.menutemplate.dtos.MenuTemplateCreateRequestDto import MenuTemplateCreateRequestDto
from src.menutemplate.dtos.MenuTemplateCreateResponseDto import MenuTemplateCreateResponseDto
from src.menutemplate.dtos.MenuTemplateResponseDto import MenuTemplateResponseDto
from di import MenuTemplateServiceDep
from src.utils.pagination.PaginationRequestDto import PaginationRequestDto
from src.utils.pagination.PaginationResponseDto import PaginationResponseDto

routes = APIRouter()

@routes.post(
  "/menu-templates/", 
  response_model= MenuTemplateCreateResponseDto, 
  tags=["menu-template"],
  name="act:create-menu-template"
)
async def createRole(
    reqDto: MenuTemplateCreateRequestDto,
    mtService: MenuTemplateServiceDep
  )->MenuTemplateCreateResponseDto:  
  return mtService.createMenuTemplate(reqDto)

@routes.get("/menu-templates/{id:int}", tags=["menu-template"], name="act:get-menu-template")
async def getById(id: int, mtService: MenuTemplateServiceDep)-> MenuTemplateResponseDto:
  return mtService.getById(id)

@routes.post(
  "/menu-templates/all",
  tags=["menu-template"],
  name="act:get-menu-templates",
  response_model=PaginationResponseDto[MenuTemplateResponseDto]
)
async def getMenuTemplates(
  reqDto: PaginationRequestDto, 
  mtService: MenuTemplateServiceDep
) -> PaginationResponseDto[MenuTemplateResponseDto]:  
  return mtService.getMenuTemplates(reqDto)

@routes.get(
  "/menu-templates/tree",
  tags=["menu-template"],
  name="act:get-user-menu-tree",
  response_model=List[Any]
)
async def getMenuTree(
  userId: int, 
  orgId: int,
  mtService: MenuTemplateServiceDep
) -> List[Any]:
  """
  Fetch the menu tree assigned to a specific user within an organization.
  """
  return mtService.getMenuTreeByUserIdAndOrgId(userId, orgId)

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\menutemplate\dtos\MenuTemplateCreateRequestDto.py
from dataclasses import dataclass
from pydantic import constr

@dataclass
class MenuTemplateCreateRequestDto:
  name: constr(min_length=1) # type: ignore
  # Removed: roleId
  orgId: int 
  tree: constr(min_length=1) # type: ignore

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\menutemplate\dtos\MenuTemplateCreateResponseDto.py
from dataclasses import dataclass
from pydantic import constr

@dataclass
class MenuTemplateCreateResponseDto:
  id: int
  name: str
  orgId: int
  tree: str

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\menutemplate\dtos\MenuTemplateResponseDto.py
from dataclasses import dataclass

@dataclass
class MenuTemplateResponseDto:
  id: int
  name: str
  orgId: int
  tree: str
  orgName: str

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\menutemplate\model\MenuTemplate.py
from sqlmodel import Field, SQLModel, Relationship
from typing import Optional
from datetime import datetime
from sqlalchemy import Column, DateTime, func

class MenuTemplate(SQLModel, table=True):
  id: int = Field(default=None, primary_key=True)
  name: str = Field(default=None, nullable=False)
  orgId: Optional[int] = Field(default=None, foreign_key="organization.id")
  org: Optional["Organization"] = Relationship(back_populates="menuTemplates") # type: ignore 
  tree: str = Field(default=None, nullable=False)
  
  # 1. Added relationship back to UserOrgLink
  userOrgLinks: list["UserOrgLink"] = Relationship(back_populates="menuTemplate") # type: ignore 

  createdAt: Optional[datetime] = Field(
    sa_column=Column(
      DateTime(timezone=True), server_default=func.now(), nullable=True
    )
  )
  updatedAt: Optional[datetime] = Field(
    sa_column=Column(
      DateTime(timezone=True), onupdate=func.now(), nullable=True
    )
  )

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\menutemplate\repository\MenuTemplateRepository.py
from abc import ABC, abstractmethod
from src.menutemplate.model.MenuTemplate import MenuTemplate

class MenuTemplateRepository(ABC):
  @abstractmethod
  def getMenuTemplateById(self, id: int) -> MenuTemplate:
    pass

  @abstractmethod
  def add(self, role: MenuTemplate) -> MenuTemplate:
    pass

  @abstractmethod
  def getAllMenuTemplate(self, rows: int, page: int, orgId: int) -> list[MenuTemplate]:
    pass

  @abstractmethod
  def countAllMenuTemplate(self, orgId: int) -> int:
    pass

  @abstractmethod
  def getByUserIdAndOrgId(self, userId: int, orgId: int) -> MenuTemplate:
    pass

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\menutemplate\repository\MenuTemplateRepositoryImp.py
from src.db.links.UserOrgLink import UserOrgLink
from src.menutemplate.repository.MenuTemplateRepository import MenuTemplateRepository
from src.menutemplate.model.MenuTemplate import MenuTemplate
from db import DBSessionDep
from fastapi import status, HTTPException
from sqlmodel import select
from sqlalchemy import func

class MenuTemplateRepositoryImp(MenuTemplateRepository):
  def __init__(self, db: DBSessionDep):
    self.db = db

  def getMenuTemplateById(self, id: int) -> MenuTemplate:
    mt = self.db.get(MenuTemplate,id)

    if not mt:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Menu template not found")
    
    return mt

  def add(self, mt: MenuTemplate) -> MenuTemplate:    
    self.db.add(mt)
    self.db.commit()
    self.db.refresh(mt)

    return mt
  
  def getAllMenuTemplate(self, rows: int, page: int, orgId: int)->list[MenuTemplate]:
    offset: int = (page - 1) * rows
    return self.db.exec(
      select(MenuTemplate)
      .where(MenuTemplate.orgId == orgId)
      .offset(offset).limit(rows)
    ).all()
  
  def countAllMenuTemplate(self, orgId: int) -> int:
    return self.db.exec(
      select(func.count(MenuTemplate.id))
      .where(MenuTemplate.orgId == orgId)
    ).one()
  
  def getByUserIdAndOrgId(self, userId: int, orgId: int) -> MenuTemplate:
    # SQL: SELECT * FROM menutemplate 
    #      JOIN userorglink ON menutemplate.id = userorglink.menuTemplateId
    #      WHERE userorglink.userId = :userId AND userorglink.orgId = :orgId
    
    statement = (
      select(MenuTemplate)
      .join(UserOrgLink, MenuTemplate.id == UserOrgLink.menuTemplateId)
      .where(UserOrgLink.userId == userId)
      .where(UserOrgLink.orgId == orgId)
    )
    
    result = self.db.exec(statement).first()

    if not result:
      raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND, 
        detail="No menu template found for this user and organization!"
      )
      
    return result



  

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\menutemplate\services\MenuTemplateService.py
import json
from typing import Any, List
from src.menutemplate.repository.MenuTemplateRepository import MenuTemplateRepository
from src.menutemplate.dtos.MenuTemplateCreateRequestDto import MenuTemplateCreateRequestDto
from src.menutemplate.dtos.MenuTemplateCreateResponseDto import MenuTemplateCreateResponseDto
from src.menutemplate.dtos.MenuTemplateResponseDto import MenuTemplateResponseDto
from src.menutemplate.model.MenuTemplate import MenuTemplate
from src.utils.pagination.PaginationRequestDto import PaginationRequestDto
from src.utils.pagination.PaginationResponseDto import PaginationResponseDto

class MenuTemplateService:
  def __init__(self, mtRepository : MenuTemplateRepository):
    self.repo = mtRepository

  def createMenuTemplate(self, reqDto: MenuTemplateCreateRequestDto) -> MenuTemplateCreateResponseDto:
    newMt = self.repo.add(MenuTemplate(
      name=reqDto.name,
      orgId=reqDto.orgId,
      tree=reqDto.tree
    ))
    
    resMt = MenuTemplateCreateResponseDto(
      id=newMt.id,
      name=reqDto.name,
      orgId=reqDto.orgId,
      tree=reqDto.tree
    )
    
    return resMt

  def getById(self, id: int) -> MenuTemplateResponseDto:
    mt = self.repo.getMenuTemplateById(id=id)
    return MenuTemplateResponseDto(
      id=mt.id,
      name=mt.name,
      orgId=mt.orgId,
      orgName=mt.org.name,
      tree=mt.tree
    )
  
  def getMenuTemplates(self, reqDto: PaginationRequestDto) -> PaginationResponseDto[MenuTemplateResponseDto]:
    total: int|None = reqDto.total
    mtResponseDtoList: list[MenuTemplateResponseDto] = []
    
    menuTemplates: list[MenuTemplate] = self.repo.getAllMenuTemplate(
      rows=reqDto.rows, 
      page=reqDto.page, 
      orgId=reqDto.orgId
    )

    if reqDto.total is None or reqDto.total == 0:
      total = self.repo.countAllMenuTemplate(orgId=reqDto.orgId)

    for mt in menuTemplates:
      mtDto: MenuTemplateResponseDto = MenuTemplateResponseDto(
        id=mt.id,
        name=mt.name,
        orgId=mt.orgId,
        orgName=mt.org.name,
        tree=mt.tree
      )
      mtResponseDtoList.append(mtDto)

    return PaginationResponseDto[MenuTemplateResponseDto](items=mtResponseDtoList, total=total)
  
  def getMenuTreeByUserIdAndOrgId(self, userId: int, orgId: int) -> List[Any]:
    menuTemplate = self.repo.getByUserIdAndOrgId(userId, orgId)
    
    # The tree is stored as a string in DB, we parse it to return actual JSON
    try:
      return json.loads(menuTemplate.tree)
    except json.JSONDecodeError:
      # Fallback if data is corrupted or empty
      return []

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\metrics\MetricsInsecureRouter.py
from fastapi import APIRouter
from di import MetricsServiceDep
from src.metrics.dtos.MetricsTrackRequestDto import MetricsTrackRequestDto
from src.metrics.dtos.MetricsTrackResponseDto import MetricsTrackResponseDto
from src.metrics.model.TriggerMode import TriggerMode

routes = APIRouter()

@routes.post(
  "/metrics/track", 
  tags=["metrics"],
  name="act:track-metric",
  response_model=MetricsTrackResponseDto
)
async def trackMetric(
    reqDto: MetricsTrackRequestDto,
    service: MetricsServiceDep
  ):
  """
  Public endpoint to track metrics.
  Does not require Authentication headers.
  """
  return service.trackMetric(reqDto)

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\metrics\MetricsRouter.py
from fastapi import APIRouter
from di import MetricsServiceDep
from src.metrics.dtos.MetricsCreateRequestDto import MetricsCreateRequestDto
from src.metrics.dtos.MetricsResponseDto import MetricsResponseDto
from src.metrics.dtos.MetricsTrackResponseDto import MetricsTrackResponseDto
from src.metrics.model.TriggerMode import TriggerMode

routes = APIRouter()

@routes.post(
  "/experiments/{experimentId}/metrics", 
  response_model=MetricsResponseDto, 
  tags=["metrics"],
  name="act:create-metric"
)
async def createMetric(
    experimentId: int,
    reqDto: MetricsCreateRequestDto,
    service: MetricsServiceDep
  ) -> MetricsResponseDto:
  return service.createMetric(experimentId, reqDto)

@routes.get(
  "/experiments/{experimentId}/metrics", 
  response_model=list[MetricsResponseDto], 
  tags=["metrics"],
  name="act:get-metrics"
)
async def getMetrics(
    experimentId: int,
    service: MetricsServiceDep
  ) -> list[MetricsResponseDto]:
  return service.getMetrics(experimentId)

@routes.delete(
  "/metrics/{id}", 
  response_model=MetricsResponseDto, 
  tags=["metrics"],
  name="act:delete-metric"
) 
async def deleteMetric(
    id: int,
    service: MetricsServiceDep
  ) -> MetricsResponseDto:
  return service.deleteMetric(id)

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\metrics\dtos\MetricsCreateRequestDto.py
from typing import Optional
from pydantic import BaseModel, model_validator

class MetricsCreateRequestDto(BaseModel):
  title: str
  custom: bool = False
  selector: Optional[str] = None
  description: Optional[str] = None

  @model_validator(mode='after')
  def validate_selector(self):
    # If it is NOT a custom event (meaning it tracks clicks/elements), a selector is required.
    if not self.custom and not self.selector:
      raise ValueError("Selector is required for non-custom metrics")
    return self

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\metrics\dtos\MetricsResponseDto.py
from dataclasses import dataclass
from typing import Optional

@dataclass
class MetricsResponseDto:
  id: int
  experimentId: int
  title: str
  custom: bool
  selector: Optional[str]
  description: Optional[str]
  triggeredOnLIVE: int
  triggeredOnQA: int

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\metrics\dtos\MetricsTrackRequestDto.py
from dataclasses import dataclass
from typing import Optional

@dataclass
class MetricsTrackRequestDto:
    # Required fields first
    experimentId: int
    custom: bool
    
    # Optional fields follow
    metricsId: Optional[int] = None
    eventName: Optional[str] = None

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\metrics\dtos\MetricsTrackResponseDto.py
from dataclasses import dataclass

@dataclass
class MetricsTrackResponseDto:
  message: str
  triggered: bool = True

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\metrics\model\Metrics.py
from sqlmodel import Field, SQLModel, Relationship
from sqlalchemy import Column, DateTime, func
from datetime import datetime
from typing import Optional

class Metrics(SQLModel, table=True):
  id: int = Field(default=None, primary_key=True)
  title: str = Field(default=None, nullable=True)
  custom: bool = Field(default=False , nullable=False)
  selector: str = Field(default=None, nullable=True)
  triggeredOnLIVE: int = Field(default=0, nullable=True)
  triggeredOnQA: int = Field(default=0, nullable=True)
  experiment: Optional["Experiment"] = Relationship(back_populates="metrics") # type: ignore
  description: str = Field(default=None, nullable=True)
  experimentId: Optional[int] = Field(default=None, foreign_key="experiment.id")
  createdAt: Optional[datetime] = Field(
    sa_column=Column(
      DateTime(timezone=True), server_default=func.now(), nullable=True
    )
  )
  updatedAt: Optional[datetime] = Field(
    sa_column=Column(
      DateTime(timezone=True), onupdate=func.now(), nullable=True
    )
  )

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\metrics\model\TriggerMode.py
from enum import StrEnum

class TriggerMode(StrEnum):
  LIVE = "Live"
  QA = "QA"

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\metrics\repository\MetricsRepository.py
from abc import ABC, abstractmethod
from src.metrics.model.Metrics import Metrics
from src.metrics.model.TriggerMode import TriggerMode

class MetricsRepository(ABC):
  
  @abstractmethod
  def add(self, metric: Metrics) -> Metrics:
    pass

  @abstractmethod
  def getByExperimentId(self, experimentId: int) -> list[Metrics]:
    pass

  @abstractmethod
  def getById(self, id: int) -> Metrics:
    pass

  @abstractmethod
  def delete(self, metric: Metrics):
    pass

  @abstractmethod
  def incrementTrigger(self, id: int, mode: TriggerMode):
    pass

  @abstractmethod
  def getByExperimentAndEventName(self, experimentId: int, eventName: str) -> Metrics:
    pass

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\metrics\repository\MetricsRepositoryImp.py
from src.metrics.repository.MetricsRepository import MetricsRepository
from src.metrics.model.Metrics import Metrics
from db import DBSessionDep
from sqlmodel import select
from fastapi import status, HTTPException
from sqlalchemy import update
from src.metrics.model.TriggerMode import TriggerMode

class MetricsRepositoryImp(MetricsRepository):
  def __init__(self, db: DBSessionDep):
    self.db = db

  def add(self, metric: Metrics) -> Metrics:
    self.db.add(metric)
    self.db.commit()
    self.db.refresh(metric)
    return metric

  def getByExperimentId(self, experimentId: int) -> list[Metrics]:
    return self.db.exec(
      select(Metrics).where(Metrics.experimentId == experimentId)
    ).all()

  def getById(self, id: int) -> Metrics:
    metric = self.db.get(Metrics, id)
    if not metric:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Metric not found")
    return metric

  def delete(self, metric: Metrics):
    self.db.delete(metric)
    self.db.commit()

  def incrementTrigger(self, id: int, mode: TriggerMode):
    if mode == TriggerMode.QA:
      statement = (
        update(Metrics)
        .where(Metrics.id == id)
        .values(triggeredOnQA=Metrics.triggeredOnQA + 1) # <--- Updated
      )
    else:
      statement = (
        update(Metrics)
        .where(Metrics.id == id)
        .values(triggeredOnLIVE=Metrics.triggeredOnLIVE + 1) # <--- Updated
      )
      
    result = self.db.exec(statement)
    self.db.commit()

    if result.rowcount == 0:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Metric not found!")
    
  def getByExperimentAndEventName(self, experimentId: int, eventName: str) -> Metrics:
    statement = select(Metrics).where(
      Metrics.experimentId == experimentId,
      Metrics.selector == eventName,
      Metrics.custom == True
    )
    result = self.db.exec(statement).first()
    if not result:
      raise HTTPException(status_code=404, detail=f"Custom metric '{eventName}' not found for this experiment!")
    return result

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\metrics\services\MetricsService.py
from fastapi import HTTPException
from src.metrics.dtos.MetricsTrackRequestDto import MetricsTrackRequestDto
from src.metrics.repository.MetricsRepository import MetricsRepository
from src.experiment.repository.ExperimentRepository import ExperimentRepository
from src.metrics.dtos.MetricsCreateRequestDto import MetricsCreateRequestDto
from src.metrics.dtos.MetricsResponseDto import MetricsResponseDto
from src.metrics.model.Metrics import Metrics
from src.metrics.dtos.MetricsTrackResponseDto import MetricsTrackResponseDto
from src.metrics.model.TriggerMode import TriggerMode
from src.experiment.model.ExperimentStatus import ExperimentStatus

class MetricsService:
  def __init__(
    self, 
    repo: MetricsRepository,
    experimentRepo: ExperimentRepository
  ):
    self.repo = repo
    self.experimentRepo = experimentRepo

  def createMetric(
      self, 
      experimentId: int, 
      reqDto: MetricsCreateRequestDto
    ) -> MetricsResponseDto:
    # 1. Validate Experiment Exists
    self.experimentRepo.getById(experimentId)

    # 2. Create Metric
    newMetric = Metrics(
      title=reqDto.title,
      custom=reqDto.custom,
      selector=reqDto.selector,
      description=reqDto.description,
      experimentId=experimentId,
      triggered=0 # Default count
    )
    
    savedMetric = self.repo.add(newMetric)

    return self._mapToResponse(savedMetric)

  def getMetrics(self, experimentId: int) -> list[MetricsResponseDto]:
    self.experimentRepo.getById(experimentId)
    metrics = self.repo.getByExperimentId(experimentId)
    return [self._mapToResponse(m) for m in metrics]

  def deleteMetric(self, id: int) -> MetricsResponseDto:
    metric = self.repo.getById(id)
    self.repo.delete(metric)
    return self._mapToResponse(metric)

  def trackMetric(self, reqDto: MetricsTrackRequestDto):
    # Resolve the Metric Object
    if reqDto.custom:
      if not reqDto.eventName:
        raise HTTPException(status_code=400, detail="Event Name is required for custom metrics!")
        
      # Find the metric ID based on the event name (selector)
      metric = self.repo.getByExperimentAndEventName(reqDto.experimentId, reqDto.eventName)

    else:
      if not reqDto.metricsId:
        raise HTTPException(status_code=400, detail="Metric ID is required for standard metrics!")
        
      metric = self.repo.getById(reqDto.metricsId)

    # Determine Mode (QA vs Live)
    # We fetch experiment to check status
    experiment = self.experimentRepo.getById(metric.experimentId)
    
    mode = TriggerMode.LIVE if experiment.status == ExperimentStatus.ACTIVE else TriggerMode.QA

    # Increment Counter
    self.repo.incrementTrigger(metric.id, mode)

    return MetricsTrackResponseDto(
      message=f"Metric tracked successfully in {mode} mode"
    )

  def _mapToResponse(self, m: Metrics) -> MetricsResponseDto:
    return MetricsResponseDto(
      id=m.id,
      experimentId=m.experimentId, # type: ignore
      title=m.title, # type: ignore
      custom=m.custom,
      selector=m.selector,
      description=m.description,
      triggeredOnQA=m.triggeredOnQA if m.triggeredOnQA else 0, # <--- Added
      triggeredOnLIVE=m.triggeredOnLIVE if m.triggeredOnLIVE else 0 # <--- Added
    )

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\org\OrgRouter.py
from fastapi import APIRouter
from src.org.dtos.OrgCreateRequestDto import OrgCreateRequestDto
from src.org.dtos.OrgCreateResponseDto import OrgCreateResponseDto
from di import OrgServiceDep
from src.org.dtos.OrgSearchResDto import OrgSearchResDto

routes = APIRouter()

@routes.post(
  "/organizations", 
  response_model=OrgCreateResponseDto, 
  tags=["organization"],
  name="act:create-organization"
)
async def createOrganization(
    # 1. Switched to the new Create DTOs
    reqDto: OrgCreateRequestDto,
    orgService: OrgServiceDep
  ) -> OrgCreateResponseDto:
  print("Creating organization with email:", reqDto.email)
  return orgService.createOrg(reqDto)

@routes.get(
  "/organizations/search",
  response_model=list[OrgSearchResDto],
  tags=["organization"],
  name="act:search-organization"
)
async def searchOrganizations(
  q: str, 
  orgService: OrgServiceDep
) -> list[OrgSearchResDto]:
  """
  Autocomplete search for organizations by name.
  Usage: GET /organizations/search?q=Comp
  """
  return orgService.searchOrg(q)

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\org\dtos\OrgAddReqDto.py
from dataclasses import dataclass
from pydantic import constr, EmailStr

@dataclass
class OrgAddReqDto:
  # 1. The email of the existing user to add
  email: EmailStr
  
  # 2. The domain of the organization to add them to
  domain: constr(min_length=1) # type: ignore
  
  # 3. Permissions are mandatory when adding a user
  roleId: int
  menuTemplateId: int

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\org\dtos\OrgAddResDto.py
from dataclasses import dataclass

@dataclass
class OrgAddResDto:
  id: int
  name: str 
  email: str

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\org\dtos\OrgCreateRequestDto.py
from dataclasses import dataclass
from pydantic import constr, EmailStr, field_validator
from config import Config

@dataclass
class OrgCreateRequestDto:
  name: constr(min_length=1) # type: ignore
  email: EmailStr
  password: constr(min_length=1) # type: ignore

  # 1. Added password validation logic here since this request creates a new user
  @field_validator("password")
  def validatePassword(cls, password):
    if len(password) < int(Config.getValByKey("PASSWORD_MAX_CHAR")):
      raise ValueError(f"Password must be at least {Config.getValByKey("PASSWORD_MAX_CHAR")} characters long!")
    if not any(char.isupper() for char in password):
      raise ValueError("Password must contain at least one uppercase letter!")
    if not any(char.islower() for char in password):
      raise ValueError("Password must contain at least one lowercase letter!")
    if not any(char.isdigit() for char in password):
      raise ValueError("Password must contain at least one digit!")
    if not any(char in "!@#$%^&*()" for char in password):
      raise ValueError("Password must contain at least one special character!")
    return password

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\org\dtos\OrgCreateResponseDto.py
from dataclasses import dataclass

@dataclass
class OrgCreateResponseDto:
  id: int
  name: str 
  email: str

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\org\dtos\OrgResDto.py
from dataclasses import dataclass

@dataclass
class OrgResDto:
  id: int
  name: str 
  email: str

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\org\dtos\OrgSearchResDto.py
from dataclasses import dataclass

@dataclass
class OrgSearchResDto:
  id: int
  name: str

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\org\model\Organization.py
from sqlmodel import Field, SQLModel, Relationship, Column, DateTime, func
from typing import Optional
from datetime import datetime
from src.db.links.UserOrgLink import UserOrgLink

class Organization(SQLModel, table=True):
  id: int = Field(default=None, primary_key=True)
  name: str = Field(index=True, nullable=True)
  email: str = Field(index=True, nullable=True)
  domain: str = Field(unique=True, default=None, nullable=True)
  disabled: bool = Field(default=False , nullable=False)
  roles: list["Role"] = Relationship(back_populates="org") # type: ignore
  users: list["User"] = Relationship(back_populates="orgs", link_model=UserOrgLink) # type: ignore
  menuTemplates: list["MenuTemplate"] = Relationship(back_populates="org") # type: ignore
  projects: list["Project"] = Relationship(back_populates="org") # type: ignore
  
  createdAt: Optional[datetime] = Field(
    sa_column=Column(
      DateTime(timezone=True), server_default=func.now(), nullable=True
    )
  )
  updatedAt: Optional[datetime] = Field(
    sa_column=Column(
      DateTime(timezone=True), onupdate=func.now(), nullable=True
    )
  )

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\org\repository\OrgRepository.py
from abc import ABC, abstractmethod
from src.org.model.Organization import Organization

class OrgRepository(ABC):

  @abstractmethod
  def getByDomain(self, domain: str) -> Organization:
    pass

  @abstractmethod
  def add(self, org: Organization) -> Organization:
    pass

  @abstractmethod
  def search(self, query: str, limit: int = 10) -> list[Organization]:
    pass

  @abstractmethod
  def getById(self, id: int) -> Organization:
    pass

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\org\repository\OrgRepositoryImp.py
from db import DBSessionDep
from src.org.repository.OrgRepository import OrgRepository
from src.org.model.Organization import Organization
from fastapi import status, HTTPException
from sqlmodel import select
from sqlmodel import col


class OrgRepositoryImp(OrgRepository):
  def __init__(self, db: DBSessionDep):
    self.db = db

  def getByDomain(self, domain: str) -> Organization:
    return self.db.exec(select(Organization).filter_by(domain=domain)).first()

  def add(self, org: Organization) -> Organization:
    existOrg = self.getByDomain(org.domain)

    if existOrg:
      raise HTTPException(status_code=status.HTTP_302_FOUND, detail="Organization already exist by this domain!")
    
    self.db.add(org)
    self.db.commit()
    self.db.refresh(org)

    return org
  
  def search(self, query: str, limit: int = 10) -> list[Organization]:
    return self.db.exec(
      select(Organization)
      .where(col(Organization.name).ilike(f"%{query}%"))
      .limit(limit)
    ).all()
  
  def getById(self, id: int) -> Organization:
    org = self.db.get(Organization, id)
    if not org:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Organization not found!")
    return org
  


file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\org\services\OrgService.py
import random
from src.org.repository.OrgRepository import OrgRepository
# 1. Update imports to use the new DTOs
from src.org.dtos.OrgCreateRequestDto import OrgCreateRequestDto
from src.org.dtos.OrgCreateResponseDto import OrgCreateResponseDto
from src.org.model.Organization import Organization
from src.user.repository.UserRepository import UserRepository
from src.user.model.User import User
from fastapi import HTTPException, status
from passlib.context import CryptContext
from src.utils.FileService import FileService
from src.role.repository.RoleRepository import RoleRepository
from src.role.model.Role import Role
from src.menutemplate.repository.MenuTemplateRepository import MenuTemplateRepository
from src.menutemplate.model.MenuTemplate import MenuTemplate
from src.email.EmailService import EmailService
from src.utils.Constants import OTP_POPULATION_DIGITS
from src.db.repository.UserOrgLinkRepository import UserOrgLinkRepository
from src.org.dtos.OrgSearchResDto import OrgSearchResDto
from src.project.model.Project import Project
from src.db.links.UserProjectLink import UserProjectLink
from src.db.links.PermissionType import PermissionType
from src.project.repository.ProjectRepository import ProjectRepository
from src.db.repository.UserProjectLinkRepository import UserProjectLinkRepository

class OrgService:
  def __init__(
      self, 
      orgRepo: OrgRepository, 
      userRepo: UserRepository,
      roleRepo: RoleRepository,
      crypto: CryptContext,
      fileService: FileService,
      emailService : EmailService,
      userOrgLinkRepo: UserOrgLinkRepository,
      mtRepo: MenuTemplateRepository,
      projectRepo: ProjectRepository,
      userProjectLinkRepo: UserProjectLinkRepository
    ):
    self.repo = orgRepo
    self.userRepo = userRepo
    self.roleRepo = roleRepo
    self.crypto = crypto
    self.fileService = fileService
    self.emailService = emailService
    self.userOrgLinkRepo = userOrgLinkRepo
    self.mtRepo = mtRepo
    self.projectRepo = projectRepo
    self.userProjectLinkRepo = userProjectLinkRepo

  # 2. Update signature to use OrgCreateRequestDto -> OrgCreateResponseDto
  def createOrg(self, reqDto: OrgCreateRequestDto) -> OrgCreateResponseDto:
    
    try:
      domain = reqDto.email.split("@")[1]
      domainName = domain.split(".")[0]
    except IndexError:
      raise HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid email format"
      )

    existingOrg = self.repo.getByDomain(domain)
    if existingOrg:
      raise HTTPException(
        status_code=status.HTTP_409_CONFLICT, 
        detail="Organization already exists with this domain!"
      )
    
    existingUser = self.userRepo.getUserByEmail(reqDto.email)
    if existingUser:
      raise HTTPException(
        status_code=status.HTTP_409_CONFLICT,
        detail="User already exists with this email!"
      )

    newOrg = self.repo.add(Organization(
      name=reqDto.name,
      email=reqDto.email,
      domain=domain
    ))

    adminRole = self.roleRepo.add(Role(name="Admin",orgId=newOrg.id))

    adminMenuTree = self.fileService.readFile("static/menu.json")
    
    adminMenuTemplate = self.mtRepo.add(MenuTemplate(
      name="Admin Menu Template",
      orgId=newOrg.id,
      tree=adminMenuTree
    ))

    otp = self.generateOtp()

    truncatedPassword = reqDto.password[:72]
    
    newUser = self.userRepo.add(User(
      email=reqDto.email,
      password=self.crypto.hash(truncatedPassword),
      verified=False, 
      otp=otp,
      orgs=[newOrg],
      projects=[],
    ))

    userOrgLink = self.userOrgLinkRepo.get(userId=newUser.id, orgId=newOrg.id)
    if userOrgLink:
      userOrgLink.roleId = adminRole.id
      userOrgLink.menuTemplateId = adminMenuTemplate.id
      userOrgLink.super = True 
      userOrgLink.disabled = False
      self.userOrgLinkRepo.edit(userOrgLink)

    defaultProject = self.projectRepo.add(Project(
      name=f"{domainName.capitalize()} Project",
      description=f"Automatically created {domainName} project, during organization registration.",
      orgId=newOrg.id
    ))

    self.userProjectLinkRepo.add(UserProjectLink(
      userId=newUser.id,
      projectId=defaultProject.id,
      super=True,
      permissionType=PermissionType.OWNER,
      disabled=False
    ))

    self.emailService.sendAccountVerificationOtp(newUser.email, otp)

    return OrgCreateResponseDto(
      id=newOrg.id, 
      name=newOrg.name, 
      email=newOrg.email
    )
  
  def generateOtp(self)->str:
    otp = ''.join(random.choices(OTP_POPULATION_DIGITS, k=6))
    return otp
  
  def searchOrg(self, query: str) -> list[OrgSearchResDto]:
    # We limit to 10 results to keep the autocomplete fast
    orgs = self.repo.search(query, limit=10)
    
    return [
      OrgSearchResDto(id=o.id, name=o.name) 
      for o in orgs
    ]

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\project\ProjectRouter.py
from fastapi import APIRouter, Request, status, HTTPException
from di import ProjectServiceDep, UserServiceDep
from src.project.dtos.ProjectCreateRequestDto import ProjectCreateRequestDto
from src.project.dtos.ProjectCreateResponseDto import ProjectCreateResponseDto
from src.project.dtos.ProjectResponseDto import ProjectResponseDto
from src.utils.pagination.PaginationRequestDto import PaginationRequestDto
from src.utils.pagination.PaginationResponseDto import PaginationResponseDto
from src.project.dtos.ProjectAssignUserRequestDto import ProjectAssignUserRequestDto
from src.project.dtos.ProjectAssignUserResponseDto import ProjectAssignUserResponseDto
from src.project.dtos.ProjectRemoveUserResponseDto import ProjectRemoveUserResponseDto

routes = APIRouter()

@routes.post(
  "/projects/", 
  response_model=ProjectCreateResponseDto, 
  tags=["project"],
  name="act:create-project"
)
async def createProject(
    reqDto: ProjectCreateRequestDto,
    projectService: ProjectServiceDep,
    userService: UserServiceDep,
    request: Request
  ) -> ProjectCreateResponseDto:
  
  # Extract email from header (set by AuthMiddleware)
  email = request.headers.get("email")
  if not email:
      raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="User email not found")
      
  # We need the User ID to link them to the project
  user = userService.repo.getUserByEmail(email)
  if not user:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")

  return projectService.createProject(reqDto, user.id)

@routes.post(
  "/projects/all",
  tags=["project"],
  name="act:get-projects",
  response_model=PaginationResponseDto[ProjectResponseDto]
)
async def getProjects(
  reqDto: PaginationRequestDto, 
  projectService: ProjectServiceDep
) -> PaginationResponseDto[ProjectResponseDto]:  
  return projectService.getProjects(reqDto)

@routes.post(
  "/projects/{projectId}/users",
  tags=["project"],
  name="act:assign-user-to-project",
  response_model=ProjectAssignUserResponseDto
)
async def assignUserToProject(
  projectId: int,
  reqDto: ProjectAssignUserRequestDto,
  projectService: ProjectServiceDep
) -> ProjectAssignUserResponseDto:
  """
  Assign an existing user to a project with a specific permission level.
  """
  return projectService.assignUser(projectId, reqDto)

@routes.get(
  "/projects/user/{userId}/org/{orgId}",
  tags=["project"],
  name="act:get-projects-by-user-and-org",
  response_model=list[ProjectResponseDto]
)
async def getProjectsByUserIdAndOrgId(
  userId: int,
  orgId: int,
  projectService: ProjectServiceDep
) -> list[ProjectResponseDto]:
  """
  Get all projects assigned to a specific user.
  """
  return projectService.getProjectsByUserIdAndOrgId(userId, orgId)


@routes.delete(
  "/projects/{projectId}/users/{userId}",
  tags=["project"],
  name="act:remove-user-from-project",
  response_model=ProjectRemoveUserResponseDto
)
async def removeUserFromProject(
  projectId: int,
  userId: int,
  projectService: ProjectServiceDep
) -> ProjectRemoveUserResponseDto:
  """
  Remove (unassign) a user from a specific project.
  """
  return projectService.removeUserFromProject(projectId, userId)

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\project\dtos\ProjectAssignUserRequestDto.py
from dataclasses import dataclass
from src.db.links.PermissionType import PermissionType

@dataclass
class ProjectAssignUserRequestDto:
  userId: int

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\project\dtos\ProjectAssignUserResponseDto.py
from dataclasses import dataclass
from src.db.links.PermissionType import PermissionType

@dataclass
class ProjectAssignUserResponseDto:
  projectId: int
  userId: int
  message: str

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\project\dtos\ProjectCreateRequestDto.py
from dataclasses import dataclass
from pydantic import constr

@dataclass
class ProjectCreateRequestDto:
  name: constr(min_length=1) # type: ignore
  orgId: int # Required (No default value)
  description: str | None = None # Optional (Has default value, so must go last)

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\project\dtos\ProjectCreateResponseDto.py
from dataclasses import dataclass

@dataclass
class ProjectCreateResponseDto:
  id: int
  name: str
  orgId: int

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\project\dtos\ProjectRemoveUserResponseDto.py
from dataclasses import dataclass

@dataclass
class ProjectRemoveUserResponseDto:
  message: str

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\project\dtos\ProjectResponseDto.py
from dataclasses import dataclass
from typing import Optional

@dataclass
class ProjectResponseDto:
  id: int
  name: str
  description: Optional[str]
  orgId: int
  orgName: str

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\project\model\Project.py
from sqlmodel import Field, SQLModel, Relationship
from sqlalchemy import Column, DateTime, func
from datetime import datetime
from typing import Optional
from src.db.links.UserProjectLink import UserProjectLink

class Project(SQLModel, table=True):
  id: int = Field(default=None, primary_key=True)
  name: str = Field(index=True, nullable=False)
  description: str = Field(default=None, nullable=True)
  
  # Parent: Organization
  org: Optional["Organization"] = Relationship(back_populates="projects") # type: ignore
  orgId: Optional[int] = Field(default=None, foreign_key="organization.id")

  # Children: Experiments
  experiments: list["Experiment"] = Relationship(back_populates="project") # type: ignore
  
  # Access: Users (via the new link table)
  users: list["User"] = Relationship(back_populates="projects", link_model=UserProjectLink) # type: ignore

  createdAt: Optional[datetime] = Field(
    sa_column=Column(
      DateTime(timezone=True), server_default=func.now(), nullable=True
    )
  )
  updatedAt: Optional[datetime] = Field(
    sa_column=Column(
      DateTime(timezone=True), onupdate=func.now(), nullable=True
    )
  )

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\project\repository\ProjectRepository.py
from abc import ABC, abstractmethod
from src.db.links.UserProjectLink import UserProjectLink
from src.project.model.Project import Project

class ProjectRepository(ABC):
  @abstractmethod
  def getProjectById(self, id: int) -> Project:
    pass

  @abstractmethod
  def add(self, project: Project) -> Project:
    pass

  @abstractmethod
  def getAllProjects(self, rows: int, page: int, orgId: int) -> list[Project]:
    pass

  @abstractmethod
  def countAllProjects(self, orgId: int) -> int:
    pass

  @abstractmethod
  def getAllByUserId(self, userId: int) -> list[tuple[Project, UserProjectLink]]:
    pass

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\project\repository\ProjectRepositoryImp.py
from src.db.links.UserProjectLink import UserProjectLink
from src.project.repository.ProjectRepository import ProjectRepository
from src.project.model.Project import Project
from db import DBSessionDep
from fastapi import status, HTTPException
from sqlmodel import select
from sqlalchemy import func
from sqlalchemy.orm import selectinload

class ProjectRepositoryImp(ProjectRepository):
  def __init__(self, db: DBSessionDep):
    self.db = db

  def getProjectById(self, id: int) -> Project:
    project = self.db.get(Project, id)
    if not project:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Project not found!")
    return project

  def add(self, project: Project) -> Project:
    # Optional: Check if project name exists within the SAME org
    existProject = self.db.exec(
      select(Project)
      .where(Project.name == project.name)
      .where(Project.orgId == project.orgId)
    ).first()

    if existProject:
      raise HTTPException(status_code=status.HTTP_302_FOUND, detail="Project already exists in this organization!")
    
    self.db.add(project)
    self.db.commit()
    self.db.refresh(project)
    return project
  
  def getAllProjects(self, rows: int, page: int, orgId: int) -> list[Project]:
    offset: int = (page - 1) * rows
    return self.db.exec(
      select(Project)
      .where(Project.orgId == orgId)
      .offset(offset).limit(rows)
    ).all()
  
  def countAllProjects(self, orgId: int) -> int:
    return self.db.exec(
      select(func.count(Project.id))
      .where(Project.orgId == orgId)
    ).one()
  
  def getAllByUserId(self, userId: int) -> list[tuple[Project, UserProjectLink]]:
    return self.db.exec(
      select(Project, UserProjectLink)
      .join(UserProjectLink, Project.id == UserProjectLink.projectId)
      .where(UserProjectLink.userId == userId)
      .options(selectinload(Project.org))
    ).all()

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\project\services\ProjectService.py
from src.db.repository.UserOrgLinkRepository import UserOrgLinkRepository
from src.project.repository.ProjectRepository import ProjectRepository
from src.db.repository.UserProjectLinkRepository import UserProjectLinkRepository
from src.project.dtos.ProjectCreateRequestDto import ProjectCreateRequestDto
from src.project.dtos.ProjectCreateResponseDto import ProjectCreateResponseDto
from src.project.dtos.ProjectResponseDto import ProjectResponseDto
from src.project.model.Project import Project
from src.db.links.UserProjectLink import UserProjectLink
from src.utils.pagination.PaginationRequestDto import PaginationRequestDto
from src.utils.pagination.PaginationResponseDto import PaginationResponseDto
from src.db.links.PermissionType import PermissionType
from fastapi import status, HTTPException
from src.project.dtos.ProjectAssignUserRequestDto import ProjectAssignUserRequestDto
from src.project.dtos.ProjectAssignUserResponseDto import ProjectAssignUserResponseDto
from src.db.links.UserProjectLink import UserProjectLink
from src.project.dtos.ProjectRemoveUserResponseDto import ProjectRemoveUserResponseDto

class ProjectService:
  def __init__(
      self, 
      projectRepo: ProjectRepository, 
      linkRepo: UserProjectLinkRepository,
      userOrgLinkRepo: UserOrgLinkRepository
    ):
    self.repo = projectRepo
    self.linkRepo = linkRepo
    self.userOrgLinkRepo = userOrgLinkRepo

  def createProject(self, reqDto: ProjectCreateRequestDto, userId: int) -> ProjectCreateResponseDto:
    newProject = self.repo.add(Project(
      name=reqDto.name,
      description=reqDto.description,
      orgId=reqDto.orgId
    ))

    superAdminLinks = self.userOrgLinkRepo.getSuperAdminsByOrgId(reqDto.orgId)

    for adminLink in superAdminLinks:
      if adminLink.userId:
        self.linkRepo.add(UserProjectLink(
          userId=adminLink.userId, 
          projectId=newProject.id,
          super=True,
          disabled=False,
          permissionType=PermissionType.OWNER
        ))

    return ProjectCreateResponseDto(
      id=newProject.id,
      name=newProject.name,
      orgId=newProject.orgId
    )

  def getProjects(self, reqDto: PaginationRequestDto) -> PaginationResponseDto[ProjectResponseDto]:
    total: int | None = reqDto.total
    
    if reqDto.total is None or reqDto.total == 0:
      total = self.repo.countAllProjects(orgId=reqDto.orgId)

    projects: list[Project] = self.repo.getAllProjects(
      rows=reqDto.rows, 
      page=reqDto.page, 
      orgId=reqDto.orgId
    )

    items: list[ProjectResponseDto] = []
    for p in projects:
      items.append(ProjectResponseDto(
        id=p.id,
        name=p.name,
        description=p.description,
        orgId=p.orgId,
        orgName=p.org.name if p.org else ""
      ))

    return PaginationResponseDto[ProjectResponseDto](items=items, total=total)
  
  def assignUser(self, projectId: int, reqDto: ProjectAssignUserRequestDto) -> ProjectAssignUserResponseDto:
    # 1. Check if Project exists
    project = self.repo.getProjectById(projectId) # raises 404 if not found

    # 2. Check if User is already assigned to this project
    existingLink = self.linkRepo.get(userId=reqDto.userId, projectId=projectId)
    if existingLink:
      raise HTTPException(
        status_code=status.HTTP_409_CONFLICT, 
        detail="User is already assigned to this project!"
      )

    # 3. Create the assignment
    newLink = UserProjectLink(
      userId=reqDto.userId,
      projectId=projectId,
      permissionType=PermissionType.EDITOR,
      disabled=False,
      super=False # Default to false for regular assignments
    )
    
    self.linkRepo.add(newLink)

    return ProjectAssignUserResponseDto(
      projectId=projectId,
      userId=reqDto.userId,
      message="User assigned to project successfully"
    )

  def getProjectsByUserIdAndOrgId(self, userId: int, orgId: int) -> list[ProjectResponseDto]:
    results = self.linkRepo.getActiveProjectsByOrgIds(userId, [orgId])

    responseList = []
    for project in results:
      responseList.append(ProjectResponseDto(
        id=project.id,
        name=project.name,
        description=project.description,
        orgId=project.orgId,
        orgName=project.org.name if project.org else ""
      ))
      
    return responseList
  
  def removeUserFromProject(self, projectId: int, userId: int) -> ProjectRemoveUserResponseDto:
    # 1. Find the assignment
    link = self.linkRepo.get(userId=userId, projectId=projectId)
    
    # 2. If no link exists, we can't delete it
    if not link:
      raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND, 
        detail="User is not assigned to this project!"
      )

    # 3. Hard Delete (Remove row from DB)
    self.linkRepo.delete(link)

    return ProjectRemoveUserResponseDto(
      message="User removed from project successfully"
    )

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\role\RoleRouter.py
from fastapi import APIRouter
from src.role.dtos.RoleCreateRequestDto import RoleCreateRequestDto
from src.role.dtos.RoleCreateResponseDto import RoleCreateResponseDto
from di import RoleServiceDep
from src.utils.pagination.PaginationRequestDto import PaginationRequestDto
from src.utils.pagination.PaginationResponseDto import PaginationResponseDto
from src.role.dtos.RoleResponseDto import RoleResponseDto

routes = APIRouter()

@routes.post(
  "/roles/", 
  response_model= RoleCreateResponseDto, 
  tags=["role"],
  name="act:create-role"
)
async def createRole(
    role: RoleCreateRequestDto,
    roleService: RoleServiceDep
  )->RoleCreateResponseDto:  
  return roleService.createRole(role)


@routes.post(
  "/roles/all",
  tags=["role"],
  name="act:get-roles",
  response_model=PaginationResponseDto[RoleResponseDto]
)
async def getRoles(
  reqDto: PaginationRequestDto, 
  roleService: RoleServiceDep
) -> PaginationResponseDto[RoleResponseDto]:  
  return roleService.getRoles(reqDto)

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\role\dtos\RoleCreateRequestDto.py
from dataclasses import dataclass
from pydantic import constr

@dataclass
class RoleCreateRequestDto:
  name: constr(min_length=1) # type: ignore
  orgId: int # Added: Required to scope the role

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\role\dtos\RoleCreateResponseDto.py
from dataclasses import dataclass

@dataclass
class RoleCreateResponseDto:
  id: int
  name: str

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\role\dtos\RoleResponseDto.py
from dataclasses import dataclass

@dataclass
class RoleResponseDto:
  id: int
  name: str

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\role\model\Role.py
from sqlmodel import Field, SQLModel, Relationship
from typing import Optional
from datetime import datetime
from sqlalchemy import Column, DateTime, func

class Role(SQLModel, table=True):
  id: int = Field(default=None, primary_key=True)
  name: str = Field(default=None, nullable=True)  
  org: Optional["Organization"] = Relationship(back_populates="roles") # type: ignore 
  orgId: Optional[int] = Field(default=None, foreign_key="organization.id")
  
  # 1. Added relationship back to UserOrgLink
  # This allows you to access role.userOrgLinks to see who has this role
  userOrgLinks: list["UserOrgLink"] = Relationship(back_populates="role") # type: ignore

  createdAt: Optional[datetime] = Field(
    sa_column=Column(
      DateTime(timezone=True), server_default=func.now(), nullable=True
    )
  )
  updatedAt: Optional[datetime] = Field(
    sa_column=Column(
      DateTime(timezone=True), onupdate=func.now(), nullable=True
    )
  )

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\role\repository\RoleRepository.py
from abc import ABC, abstractmethod
from src.role.model.Role import Role

class RoleRepository(ABC):
  @abstractmethod
  def getRoleById(self, id: int) -> Role:
    pass

  @abstractmethod
  def add(self, role: Role) -> Role:
    pass

  @abstractmethod
  def getAllRole(self, rows: int, page: int, orgId: int) -> list[Role]:
    pass

  @abstractmethod
  def countAllRole(self, orgId: int) -> int:
    pass

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\role\repository\RoleRepositoryImp.py
from src.role.repository.RoleRepository import RoleRepository
from src.role.model.Role import Role
from db import DBSessionDep
from fastapi import status, HTTPException
from sqlmodel import select
from sqlalchemy import func

class RoleRepositoryImp(RoleRepository):
  def __init__(self, db: DBSessionDep):
    self.db = db

  def getRoleById(self, id: int) -> Role:
    role = self.db.get(Role, id)
    if not role:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Role not found")
    return role

  def add(self, role: Role) -> Role:
    # Change 1: Check uniqueness based on Name AND OrgId
    existRole = self.db.exec(
        select(Role)
        .where(Role.name == role.name)
        .where(Role.orgId == role.orgId)
    ).first()

    if existRole:
      # Option A: Return existing (Idempotent)
      return existRole
      # Option B: Raise Error (Strict)
      # raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Role already exists!")
    
    self.db.add(role)
    self.db.commit()
    self.db.refresh(role)
    return role
  
  def getAllRole(self, rows: int, page: int, orgId: int) -> list[Role]:
    offset: int = (page - 1) * rows
    # Change 2: Simplified query. No join needed.
    return self.db.exec(
      select(Role)
      .where(Role.orgId == orgId)
      .offset(offset).limit(rows)
    ).all()
  
  def countAllRole(self, orgId: int) -> int:
    # Change 3: Simplified count query.
    return self.db.exec(
      select(func.count(Role.id))
      .where(Role.orgId == orgId)
    ).one()

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\role\services\RoleService.py
from src.role.repository.RoleRepository import RoleRepository
from src.role.dtos.RoleCreateRequestDto import RoleCreateRequestDto
from src.role.dtos.RoleCreateResponseDto import RoleCreateResponseDto
from src.role.model.Role import Role
from src.utils.pagination.PaginationRequestDto import PaginationRequestDto
from src.utils.pagination.PaginationResponseDto import PaginationResponseDto
from src.role.dtos.RoleResponseDto import RoleResponseDto

class RoleService:
  def __init__(self, roleRepository : RoleRepository):
    self.repo = roleRepository

  def createRole(self, reqDto: RoleCreateRequestDto) -> RoleCreateResponseDto:
    # Change 1: Pass orgId to Role model
    newRole = self.repo.add(Role(
      name=reqDto.name, 
      orgId=reqDto.orgId
    ))
    resRole = RoleCreateResponseDto(id=newRole.id, name=newRole.name)
    return resRole
  
  def getRoles(self, reqDto: PaginationRequestDto) -> PaginationResponseDto[RoleResponseDto]:
    total: int|None = reqDto.total
    roleResponseDtoList: list[RoleResponseDto] = []
    
    roles: list[Role] = self.repo.getAllRole(
      rows=reqDto.rows, 
      page=reqDto.page, 
      orgId=reqDto.orgId
    )

    if reqDto.total is None or reqDto.total == 0:
      total = self.repo.countAllRole(orgId=reqDto.orgId)

    for r in roles:
      roleDto: RoleResponseDto = RoleResponseDto(
        id=r.id,
        name=r.name
      )
      roleResponseDtoList.append(roleDto)

    return PaginationResponseDto[RoleResponseDto](items=roleResponseDtoList, total=total)

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\user\UserInsecureRouter.py
from fastapi import APIRouter
from di import UserServiceDep
from src.user.dtos.UserRegistrationRequestDto import UserRegistrationRequestDto
from src.user.dtos.UserRegistrationResponseDto import UserRegistrationResponseDto
from src.user.dtos.UserVerificationRequestDto import UserVerificationRequestDto
from src.user.dtos.UserVerificationResponseDto import UserVerificationResponseDto
from src.user.dtos.ForgotPasswordOtpRequestDto import ForgotPasswordOtpRequestDto
from src.user.dtos.ForgotPasswordOtpResponseDto import ForgotPasswordOtpResponseDto
from src.user.dtos.UserJoinOrgRequestDto import UserJoinOrgRequestDto
from src.user.dtos.UserJoinOrgResponseDto import UserJoinOrgResponseDto

routes = APIRouter()

@routes.post(
  "/users/registration", 
  response_model=UserRegistrationResponseDto, 
  tags=["user"]
)
async def registration(
    reqDto: UserRegistrationRequestDto,
    userServiceDep: UserServiceDep
  )->UserRegistrationResponseDto:
  return userServiceDep.registerUser(reqDto)

@routes.post("/users/verify", tags=["user"])
async def verify(
    reqDto: UserVerificationRequestDto, 
    userService: UserServiceDep
  )-> UserVerificationResponseDto:
  return userService.verify(reqDto)

@routes.post("/users/forgot-password-otp", tags=["user"])
async def forgotPassword(
    reqDto: ForgotPasswordOtpRequestDto, 
    userService: UserServiceDep
  )-> ForgotPasswordOtpResponseDto:
  return userService.sendForgotPasswordOtp(reqDto)

@routes.post(
  "/users/join-organization", 
  tags=["user"],
  response_model=UserJoinOrgResponseDto
)
async def joinOrganization(
  reqDto: UserJoinOrgRequestDto,
  userService: UserServiceDep
) -> UserJoinOrgResponseDto:
  """
  Public endpoint for an existing, verified user to request to join an organization.
  The user will be added with 'disabled=True' until an admin approves them.
  """
  return userService.joinOrg(reqDto)

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\user\UserRouter.py
from fastapi import APIRouter, Request
from src.org.dtos.OrgAddResDto import OrgAddResDto
from src.org.dtos.OrgAddReqDto import OrgAddReqDto
from src.user.dtos.UserResponseDto import UserResponseDto
from di import UserServiceDep
from fastapi import status, HTTPException
from src.user.dtos.UpdateUserRequestDto import UpdateUserRequestDto
from src.user.dtos.UpdateUserResponseDto import UpdateUserResponseDto
from src.utils.pagination.PaginationRequestDto import PaginationRequestDto
from src.utils.pagination.PaginationResponseDto import PaginationResponseDto

routes = APIRouter()

@routes.get("/users/{id}", tags=["user"], name="act:get-user")
async def getById(id: int, userService: UserServiceDep)-> UserResponseDto:
  return userService.getUserById(id)

@routes.patch(
  "/users/{userId}/organization/{orgId}", 
  tags=["user"],
  name="act:update-user",
  response_model=UpdateUserResponseDto
)
async def updateUser(
  userId: int, 
  orgId: int,
  reqDto: UpdateUserRequestDto, 
  userService: UserServiceDep
)-> UserResponseDto:
  return userService.updateUser(userId, orgId, reqDto)

@routes.post(
  "/users/organizations", 
  tags=["user"], 
  name="act:add-organization", 
  response_model=OrgAddResDto
)
async def addOrg(
  reqDto: OrgAddReqDto, 
  userService: UserServiceDep, 
  request: Request
)-> OrgAddResDto:
  authEmail = request.headers.get("email")

  if not authEmail:
    raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="No mail found on header!")

  return userService.addOrg(reqDto, authEmail)

@routes.post(
  "/users/all",
  tags=["user"],
  name="act:get-users",
  response_model=PaginationResponseDto[UserResponseDto]
)
async def getUsers(
  reqDto: PaginationRequestDto, 
  userService: UserServiceDep
) -> PaginationResponseDto[UserResponseDto]:  
  return userService.getUsers(reqDto)

@routes.get(
  "/{userId}/orgs/{orgId}/details", 
  tags=["user"],
  name="act:get-user-org-details",
  response_model=UserResponseDto
)
def getUserDetailsByOrgAndUser(
    userId: int, 
    orgId: int, 
    userService: UserServiceDep
) -> UserResponseDto:
  """
  Get detailed user information specifically for a given organization context,
  including their Role Name and Menu Template Name.
  """
  return userService.getUserDetailsByOrgAndUser(userId, orgId)

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\user\dtos\ForgotPasswordOtpRequestDto.py
from dataclasses import dataclass
from pydantic import EmailStr, constr

@dataclass
class ForgotPasswordOtpRequestDto:
  email: EmailStr

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\user\dtos\ForgotPasswordOtpResponseDto.py
from dataclasses import dataclass

@dataclass
class ForgotPasswordOtpResponseDto:
  message: str

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\user\dtos\UpdateUserRequestDto.py
from dataclasses import dataclass
from typing import Optional

@dataclass
class UpdateUserRequestDto:
  disabled: Optional[bool] = None # Not required
  super: Optional[bool] = None # Not required
  firstName: Optional[str] = None  # Not required
  lastName: Optional[str] = None  # Not required
  contactNumber: Optional[str] = None  # Not required
  roleId: Optional[int] = None 
  menuTemplateId: Optional[int] = None

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\user\dtos\UpdateUserResponseDto.py
from dataclasses import dataclass

@dataclass
class UpdateUserResponseDto:
  id: int
  disabled: bool|None
  super: bool|None
  firstName: str
  lastName: str
  contactNumber: str

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\user\dtos\UserJoinOrgRequestDto.py
from dataclasses import dataclass
from pydantic import EmailStr

@dataclass
class UserJoinOrgRequestDto:
  email: EmailStr
  orgId: int

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\user\dtos\UserJoinOrgResponseDto.py
from dataclasses import dataclass

@dataclass
class UserJoinOrgResponseDto:
  message: str
  userId: int
  orgId: int

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\user\dtos\UserRegistrationRequestDto.py
from dataclasses import dataclass
from pydantic import EmailStr, constr, field_validator
from config import Config

@dataclass
class UserRegistrationRequestDto:
  email: EmailStr
  password: constr(min_length=1) # type: ignore
  orgId: int 
  
  @field_validator("password")
  def validatePassword(cls, password):
    if len(password) < int(Config.getValByKey("PASSWORD_MAX_CHAR")):
      raise ValueError(f"Password must be at least {Config.getValByKey("PASSWORD_MAX_CHAR")} characters long!")
    if not any(char.isupper() for char in password):
      raise ValueError("Password must contain at least one uppercase letter!")
    if not any(char.islower() for char in password):
      raise ValueError("Password must contain at least one lowercase letter!")
    if not any(char.isdigit() for char in password):
      raise ValueError("Password must contain at least one digit!")
    if not any(char in "!@#$%^&*()" for char in password):
      raise ValueError("Password must contain at least one special character!")
    return password

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\user\dtos\UserRegistrationResponseDto.py
from dataclasses import dataclass
from pydantic import EmailStr

@dataclass
class UserRegistrationResponseDto:
  id: int
  email: EmailStr
  message: str

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\user\dtos\UserResponseDto.py
from dataclasses import dataclass
from pydantic import EmailStr
from typing import Optional

@dataclass
class UserResponseDto:
  id: int
  email: EmailStr
  verified: bool
  firstName: str
  lastName: str
  contactNumber: str
  disabled: Optional[bool] = None
  super: Optional[str] = None
  roleId: Optional[int] = None
  menuTemplateId: Optional[int] = None
  roleName: Optional[str] = None
  menuTemplateName: Optional[str] = None

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\user\dtos\UserVerificationRequestDto.py
from pydantic import EmailStr, constr
from dataclasses import dataclass

@dataclass
class UserVerificationRequestDto:
  otp: constr(min_length=6) # type: ignore
  email: EmailStr
  

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\user\dtos\UserVerificationResponseDto.py
from dataclasses import dataclass

@dataclass
class UserVerificationResponseDto:
  message: str

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\user\model\User.py
from typing import Optional
from datetime import datetime
from sqlmodel import Field, SQLModel, Relationship
from sqlalchemy import Column, DateTime, func
from src.db.links.UserOrgLink import UserOrgLink
from src.db.links.UserProjectLink import UserProjectLink

class User(SQLModel, table=True):

  __tablename__ = "userinfo"

  id: int = Field(default=None, primary_key=True)
  email: str = Field(index=True)
  password: str 
  otp: str = Field(default=None, nullable=True)
  verified: bool = Field(default=False , nullable=False)
  orgs: list["Organization"] = Relationship(back_populates="users", link_model=UserOrgLink) # type: ignore
  firstName: str = Field(default=None, nullable=True)
  lastName: str = Field(default=None, nullable=True)
  contactNumber: str = Field(default=None, nullable=True)
  projects: list["Project"] = Relationship(back_populates="users", link_model=UserProjectLink) # type: ignore
  createdAt: Optional[datetime] = Field(
    sa_column=Column(
      DateTime(timezone=True), server_default=func.now(), nullable=True
    )
  )
  updatedAt: Optional[datetime] = Field(
    sa_column=Column(
      DateTime(timezone=True), onupdate=func.now(), nullable=True
    )
  )
    


file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\user\repository\UserRepository.py
from abc import ABC, abstractmethod
from src.user.model.User import User

class UserRepository(ABC):
  @abstractmethod
  def getUserById(self, id: int) -> User:
    pass

  @abstractmethod
  def add(self, user: User) -> User:
    pass

  @abstractmethod
  def getUserByEmail(self, email: str) -> User:
    pass

  @abstractmethod
  def updateUser(self, user: User) -> User:
    pass

  @abstractmethod
  def getAllUser(self, rows: int, page: int, orgId: int) -> list[User]:
    pass

  @abstractmethod
  def countAllUser(self, orgId: int) -> int:
    pass

  @abstractmethod
  def getUserDetailsByOrgAndUser(self, userId: int, orgId: int):
    pass

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\user\repository\UserRepositoryImp.py
from src.user.repository.UserRepository import UserRepository
from src.user.model.User import User
from db import DBSessionDep
from fastapi import status, HTTPException
from sqlmodel import select
from sqlalchemy import func
from src.db.links.UserOrgLink import UserOrgLink
from src.role.model.Role import Role
from src.menutemplate.model.MenuTemplate import MenuTemplate

class UserRepositoryImp(UserRepository):
  def __init__(self, db: DBSessionDep):
    self.db = db

  def getUserById(self, id: int) -> User:
    user = self.db.get(User,id)
    if not user:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")
    return user

  def add(self, user: User) -> User:
    existUser = self.db.exec(select(User).filter_by(email=user.email)).first()

    if existUser:
      raise HTTPException(status_code=status.HTTP_302_FOUND, detail="User already exist by this name!")
    
    self.db.add(user)
    self.db.commit()
    self.db.refresh(user)

    return user
  
  def getUserByEmail(self, email: str) -> User:
    return self.db.exec(select(User).filter_by(email=email)).first()
  
  def updateUser(self, user: User):

    self.db.add(user)
    self.db.commit()
    self.db.refresh(user)

    return user
  
  def getAllUser(self, rows: int, page: int, orgId: int)->list[User]:
    offset: int = (page - 1) * rows
    return self.db.exec(
      select(User, UserOrgLink, Role, MenuTemplate)
      .join(UserOrgLink, UserOrgLink.userId == User.id)
      .join(Role, UserOrgLink.roleId == Role.id, isouter=True)
      .join(MenuTemplate, UserOrgLink.menuTemplateId == MenuTemplate.id, isouter=True)
      .where(UserOrgLink.orgId == orgId)
      .offset(offset).limit(rows)
    ).all()
  
  def countAllUser(self, orgId: int) -> int:
    return self.db.exec(
      select(func.count(User.id))
      .select_from(UserOrgLink)
      .join(User, UserOrgLink.userId==User.id)
      .where(UserOrgLink.orgId == orgId)
    ).one()
  
  def getUserDetailsByOrgAndUser(self, userId: int, orgId: int):
    return self.db.exec(
      select(User, UserOrgLink, Role.name, MenuTemplate.name)
      .join(UserOrgLink, UserOrgLink.userId == User.id)
      .join(Role, UserOrgLink.roleId == Role.id, isouter=True) 
      .join(MenuTemplate, UserOrgLink.menuTemplateId == MenuTemplate.id, isouter=True)
      .where(User.id == userId)
      .where(UserOrgLink.orgId == orgId)
    ).first()
    
    

  

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\user\services\UserService.py
import random
from config import Config
from src.user.model.User import User
from datetime import datetime, timezone
from passlib.context import CryptContext
from fastapi import status, HTTPException
from src.org.dtos.OrgAddReqDto import OrgAddReqDto
from src.org.dtos.OrgAddResDto import OrgAddResDto
from src.user.dtos.UserRegistrationRequestDto import UserRegistrationRequestDto
from src.user.dtos.UserRegistrationResponseDto import UserRegistrationResponseDto
from src.user.repository.UserRepository import UserRepository
from src.user.dtos.UserResponseDto import UserResponseDto
from src.user.dtos.UserVerificationRequestDto import UserVerificationRequestDto
from src.user.dtos.UserVerificationResponseDto import UserVerificationResponseDto
from src.email.EmailService import EmailService
from src.user.dtos.ForgotPasswordOtpRequestDto import ForgotPasswordOtpRequestDto
from src.user.dtos.ForgotPasswordOtpResponseDto import ForgotPasswordOtpResponseDto
from src.org.model.Organization import Organization
from src.org.repository.OrgRepository import OrgRepository
from src.user.dtos.UpdateUserRequestDto import UpdateUserRequestDto
from src.user.dtos.UpdateUserResponseDto import UpdateUserResponseDto
from src.db.repository.UserOrgLinkRepository import UserOrgLinkRepository
from src.db.links.UserOrgLink import UserOrgLink
from src.utils.pagination.PaginationRequestDto import PaginationRequestDto
from src.utils.pagination.PaginationResponseDto import PaginationResponseDto
from src.utils.Constants import OTP_POPULATION_DIGITS, USER_CREATION_RES_MSG
from src.user.dtos.UserJoinOrgRequestDto import UserJoinOrgRequestDto
from src.user.dtos.UserJoinOrgResponseDto import UserJoinOrgResponseDto

class UserService:
  otpExpiryDuration: int = int(Config.getValByKey("OTP_EXPIRY_DURATION"))

  def __init__(
    self, 
    userRepository : UserRepository, 
    orgRepository: OrgRepository,
    userOrgLinkRepo: UserOrgLinkRepository,
    crypto: CryptContext,
    emailService : EmailService
  ):
    self.repo = userRepository
    self.crypto = crypto
    self.emailService = emailService
    self.orgRepo = orgRepository
    self.userOrgLinkRepo = userOrgLinkRepo

  def registerUser(self, reqDto : UserRegistrationRequestDto) -> UserRegistrationResponseDto:
    org = self.orgRepo.getById(reqDto.orgId)
    
    otp = self.generateOtp()
    truncatedPassword = reqDto.password[:72]
    
    newUser = self.repo.add(User(
      email=reqDto.email,
      password=self.crypto.hash(truncatedPassword),
      otp=otp,
      orgs=[org],         
      menuTemplates=[] 
    ))

    self.emailService.sendAccountVerificationOtp(newUser.email, otp)

    resUser = UserRegistrationResponseDto(
      id=newUser.id,
      email=newUser.email,
      message=USER_CREATION_RES_MSG
    )

    return resUser
  
  def getUserById(self, id: int)-> UserResponseDto:
    dbUser = self.repo.getUserById(id=id)
    return UserResponseDto(
      id=dbUser.id, 
      email=dbUser.email,
      contactNumber=dbUser.contactNumber,
      firstName=dbUser.firstName,
      lastName=dbUser.lastName,
      verified=dbUser.verified
    )
  
  def generateOtp(self)->str:
    otp = ''.join(random.choices(OTP_POPULATION_DIGITS, k=6))
    return otp
  
  def verify(self, reqDto: UserVerificationRequestDto)-> UserVerificationResponseDto:

    dbUser: User = self.repo.getUserByEmail(reqDto.email)

    if not dbUser:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="No user found by this email!")
    
    if dbUser.verified:
      raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="User already verified!")
    
    if not dbUser.createdAt:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="No otp creation date found to calculate otp expiration!")

    otpDuration: int = self.calculateSecondDiff(datetime.now(timezone.utc), dbUser.createdAt)

    if otpDuration > self.otpExpiryDuration :
      raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Otp expired!")

    if dbUser.otp != reqDto.otp:
      raise HTTPException(status_code=status.HTTP_406_NOT_ACCEPTABLE, detail="Otp didn't match!")
    
    dbUser.verified = True

    self.repo.updateUser(dbUser)

    resDto = UserVerificationResponseDto(message="User verified successfully!")
    return resDto
  
  def sendForgotPasswordOtp(
      self, 
      reqDto: ForgotPasswordOtpRequestDto
    ) -> ForgotPasswordOtpResponseDto :
    
    dbUser: User = self.repo.getUserByEmail(reqDto.email)

    if not dbUser:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="No user found by this email!")
    
    otp = self.generateOtp()
    dbUser.otp = otp
    self.repo.updateUser(dbUser)

    self.emailService.sendForgotPasswordOtp(dbUser.email, otp)

    return ForgotPasswordOtpResponseDto(message="To reset your password, a otp has been sent to your mail!")
  
  def calculateSecondDiff(self, end: datetime, start: datetime) -> int:
    timeDiff = end - start
    return timeDiff.seconds

  # 1. Update logic to use the strict fields from OrgAddReqDto
  def addOrg(self, reqDto: OrgAddReqDto, authMail: str) -> OrgAddResDto: 
    adminUser: User = self.repo.getUserByEmail(authMail)
    if not adminUser:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Admin user not found!")

    targetUser: User = self.repo.getUserByEmail(reqDto.email)
    if not targetUser:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User to add not found!")

    # 2. Domain is now mandatory in the DTO, so we use it directly
    org = self.orgRepo.getByDomain(reqDto.domain)

    if not org:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Organization not found!")

    existingLink = self.userOrgLinkRepo.get(userId=targetUser.id, orgId=org.id)
    if existingLink:
      raise HTTPException(status_code=status.HTTP_302_FOUND, detail="User is already in this organization!")
    
    newLink = UserOrgLink(
      userId=targetUser.id,
      orgId=org.id,
      roleId=reqDto.roleId,
      menuTemplateId=reqDto.menuTemplateId,
      disabled=False,
      super=False
    )
    
    self.userOrgLinkRepo.add(newLink)

    return OrgAddResDto(id=org.id, name=org.name, email=org.email)

  def updateUser(self, userId: int, orgId: int, reqDto: UpdateUserRequestDto)-> UpdateUserResponseDto:
    dbUser: User = self.repo.getUserById(userId)

    if not dbUser:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="No user found by this ID!")
    
    if reqDto.firstName:
      dbUser.firstName = reqDto.firstName

    if reqDto.lastName:
     dbUser.lastName = reqDto.lastName

    if reqDto.contactNumber:
      dbUser.contactNumber = reqDto.contactNumber

    updateUser = self.repo.updateUser(dbUser)

    userOrgLink: UserOrgLink|None = self.userOrgLinkRepo.get(userId=userId,orgId=orgId)

    if userOrgLink is not None:
      if reqDto.disabled is not None:
        userOrgLink.disabled = reqDto.disabled

      if reqDto.super is not None:
        userOrgLink.super = reqDto.super
      
      if reqDto.roleId is not None:
        userOrgLink.roleId = reqDto.roleId
        
      if reqDto.menuTemplateId is not None:
        userOrgLink.menuTemplateId = reqDto.menuTemplateId

      self.userOrgLinkRepo.edit(userOrgLink=userOrgLink)

    return UpdateUserResponseDto(
      id=updateUser.id, 
      disabled= None if userOrgLink is None else userOrgLink.disabled,
      super= None if userOrgLink is None else userOrgLink.super,
      firstName=updateUser.firstName,
      lastName=updateUser.lastName,
      contactNumber=updateUser.contactNumber
    )
  
  def getUsers(self, reqDto: PaginationRequestDto)->PaginationResponseDto[UserResponseDto]:
    total: int|None = reqDto.total
    userResponseDtoList: list[UserResponseDto] = []
    
    users: list[User] = self.repo.getAllUser(rows=reqDto.rows, page=reqDto.page, orgId=reqDto.orgId)

    if reqDto.total is None or reqDto.total == 0:
      total = self.repo.countAllUser(orgId=reqDto.orgId)

    for u,l,r,mt in users:
      
      urDto: UserResponseDto = UserResponseDto(
        id=u.id,
        email=u.email,
        contactNumber=u.contactNumber,
        firstName=u.firstName,
        lastName=u.lastName,
        verified=u.verified,
        super=l.super,
        disabled=l.disabled,
        roleId=r.id if r else None,
        menuTemplateId=mt.id if mt else None, 
        roleName=r.name if r else None,
        menuTemplateName=mt.name if mt else None
      )

      userResponseDtoList.append(urDto)

    return PaginationResponseDto[UserResponseDto](items=userResponseDtoList, total=total)
  
  def getUserDetailsByOrgAndUser(self, userId: int, orgId: int) -> UserResponseDto: 
    # 1. Call the repo method (returns Tuple of 4 items)
    result = self.repo.getUserDetailsByOrgAndUser(userId, orgId)

    if not result:
      raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND, 
        detail="User not found in this organization!"
      )
    
    # 2. Unpack the tuple
    user, link, roleName, mtName = result

    # 3. Return the DTO
    return UserResponseDto(
      id=user.id,
      email=user.email,
      verified=user.verified,
      firstName=user.firstName,
      lastName=user.lastName,
      contactNumber=user.contactNumber,
      disabled=link.disabled,
      super=link.super,
      roleId=link.roleId,
      menuTemplateId=link.menuTemplateId,
      roleName=roleName,
      menuTemplateName=mtName
    )
  
  def joinOrg(self, reqDto: UserJoinOrgRequestDto) -> UserJoinOrgResponseDto:
    # 1. Validate User
    user = self.repo.getUserByEmail(reqDto.email)
    if not user:
      raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND, 
        detail="User with this email does not exist!"
      )
    
    if not user.verified:
      raise HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST, 
        detail="User is not verified. Please verify your account first!"
      )

    # 2. Validate Organization
    org = self.orgRepo.getById(reqDto.orgId) # Raises 404 if not found

    # 3. Check for Existing Membership
    existingLink = self.userOrgLinkRepo.get(userId=user.id, orgId=org.id)
    if existingLink:
      raise HTTPException(
        status_code=status.HTTP_409_CONFLICT, 
        detail="User is already a member (or has a pending request) for this organization!"
      )

    # 4. Create Link (Defaults: Role=None, Menu=None, Disabled=True)
    newLink = UserOrgLink(
      userId=user.id,
      orgId=org.id
      # disabled defaults to True in the model, acting as a "Pending Request"
    )
    
    self.userOrgLinkRepo.add(newLink) # Ensure your repo has .add(), otherwise use .edit()

    return UserJoinOrgResponseDto(
      message="Join request sent successfully. An admin must approve your request!",
      userId=user.id,
      orgId=org.id
    )

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\utils\CacheService.py
import json
import redis # type: ignore
from typing import Optional, Any
from config import Config

class CacheService:
  def __init__(self):
    self.client = redis.from_url(Config.getValByKey("REDIS_URL"))
    self.defaultTtl = 1 # 60 seconds

  def get(self, key: str) -> Optional[Any]:
    data = self.client.get(key)
    if data:
      return json.loads(data)
    return None

  def set(self, key: str, value: Any, ttl: int = None):
    expiry = ttl if ttl is not None else self.defaultTtl
    jsonData = json.dumps(value, default=str) 
    self.client.setex(key, expiry, jsonData)

  def delete(self, key: str):
    self.client.delete(key)

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\utils\Constants.py
OTP_POPULATION_DIGITS = "0123456789"
USER_CREATION_RES_MSG = (
  "A otp has been sent to your mail, please use the otp and verify your account!"
)

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\utils\FileService.py
from pathlib import Path

class FileService:
  def readFile(self, relativePath: str) -> str:
    # Current file: src/utils/FileService.py
    # .parent = src/utils
    # .parent.parent = src
    # .parent.parent.parent = Project Root
    basePath = Path(__file__).resolve().parent.parent.parent
    filePath = basePath / relativePath
    
    try:
      with open(filePath, "r", encoding="utf-8") as f:
        return f.read()
    except FileNotFoundError:
      # Return empty JSON list as fallback
      return "[]"

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\utils\pagination\PaginationRequestDto.py
from dataclasses import dataclass
from pydantic import Field
from typing import Optional

@dataclass
class PaginationRequestDto:
  orgId: int
  rows: int = Field(..., gt=0)
  page: int = Field(..., gt=0)
  total: Optional[int] = None
  projectId: Optional[int] = None

  
  



file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\utils\pagination\PaginationResponseDto.py
from dataclasses import dataclass

@dataclass
class PaginationResponseDto[T]:
  items: list[T]
  total: int

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\variation\VariationRouter.py
from fastapi import APIRouter
from di import VariationServiceDep
from src.variation.dtos.VariationCreateRequestDto import VariationCreateRequestDto
from src.variation.dtos.VariationResponseDto import VariationResponseDto
from src.variation.dtos.VariationUpdateRequestDto import VariationUpdateRequestDto
from src.variation.dtos.TrafficAllocationRequestDto import TrafficAllocationRequestDto

routes = APIRouter()

@routes.post(
  "/experiments/{experimentId}/variations", 
  response_model=VariationResponseDto, 
  tags=["variation"],
  name="act:create-variation"
)
async def createVariation(
    experimentId: int,
    reqDto: VariationCreateRequestDto,
    service: VariationServiceDep
  ) -> VariationResponseDto:
  return service.createVariation(experimentId, reqDto)

# 1. PATCH: Update general variation details
@routes.patch(
  "/variations/{id}",
  response_model=VariationResponseDto,
  tags=["variation"],
  name="act:update-variation"
)
async def updateVariation(
  id: int,
  reqDto: VariationUpdateRequestDto,
  service: VariationServiceDep
) -> VariationResponseDto:
  return service.updateVariation(id, reqDto)

# 2. PUT: Update traffic allocation (Bulk)
@routes.put(
  "/experiments/{experimentId}/traffic",
  response_model=list[VariationResponseDto],
  tags=["variation"],
  name="act:update-traffic-allocation"
)
async def updateTrafficAllocation(
  experimentId: int,
  reqDto: TrafficAllocationRequestDto,
  service: VariationServiceDep
) -> list[VariationResponseDto]:
  return service.updateTrafficAllocation(experimentId, reqDto)

@routes.get(
  "/experiments/{experimentId}/variations", 
  response_model=list[VariationResponseDto], 
  tags=["variation"],
  name="act:get-variations"
)
async def getVariations(
    experimentId: int,
    service: VariationServiceDep
  ) -> list[VariationResponseDto]:
  """
  Get all variations associated with a specific experiment.
  """
  return service.getVariations(experimentId)

@routes.delete(
  "/variations/{id}",
  response_model=VariationResponseDto,
  tags=["variation"],
  name="act:delete-variation"
)
async def deleteVariation(
  id: int,
  service: VariationServiceDep
) -> VariationResponseDto:
  """
  Delete a variation. 
  Note: The Control variation cannot be deleted.
  """
  return service.deleteVariation(id)

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\variation\dtos\TrafficAllocationRequestDto.py
from dataclasses import dataclass
from typing import List
from pydantic import BaseModel, field_validator

class VariationTrafficDto(BaseModel):
  variationId: int
  traffic: int

class TrafficAllocationRequestDto(BaseModel):
  allocations: List[VariationTrafficDto]

  @field_validator('allocations')
  def validate_total_traffic(cls, v):
    total = sum(item.traffic for item in v)
    if total != 100:
      raise ValueError(f"Total traffic allocation must equal 100%. Current total: {total}%!")
    return v

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\variation\dtos\VariationCreateRequestDto.py
from dataclasses import dataclass
from typing import Optional
from pydantic import constr

@dataclass
class VariationCreateRequestDto:
  title: constr(min_length=1) # type: ignore
  js: Optional[str] = None
  css: Optional[str] = None

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\variation\dtos\VariationResponseDto.py
from dataclasses import dataclass
from typing import Optional

@dataclass
class VariationResponseDto:
  id: int
  experimentId: int
  title: str
  traffic: int
  js: Optional[str]
  css: Optional[str]
  isControl: bool

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\variation\dtos\VariationUpdateRequestDto.py
from typing import Optional
from pydantic import BaseModel, model_validator, constr

class VariationUpdateRequestDto(BaseModel):
  title: Optional[str] = None
  js: Optional[str] = None
  css: Optional[str] = None

  @model_validator(mode='after')
  def check_at_least_one_field(self):
    if not any(value is not None for value in self.__dict__.values()):
      raise ValueError("At least one field (title, js, css) must be provided!")
    return self

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\variation\model\Variation.py
from sqlmodel import Field, SQLModel, Relationship
from sqlalchemy import Text, Column, DateTime, func
from typing import Optional
from datetime import datetime

class Variation(SQLModel, table=True):
  id: int = Field(default=None, primary_key=True)
  js: str = Field(default=None, nullable=True, sa_type=Text)
  css: str = Field(default=None, nullable=True, sa_type=Text)
  title: str = Field(default=None, nullable=True)
  traffic: int = Field(default=None, nullable=True)
  isControl: bool = Field(default=False, nullable=False)
  experiment: Optional["Experiment"] = Relationship(back_populates="variations") # type: ignore
  experimentId: Optional[int] = Field(default=None, foreign_key="experiment.id")
  createdAt: Optional[datetime] = Field(
    sa_column=Column(
      DateTime(timezone=True), server_default=func.now(), nullable=True
    )
  )
  updatedAt: Optional[datetime] = Field(
    sa_column=Column(
      DateTime(timezone=True), onupdate=func.now(), nullable=True
    )
  )

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\variation\repository\VariationRepository.py
from abc import ABC, abstractmethod
from src.variation.model.Variation import Variation

class VariationRepository(ABC):
  
  @abstractmethod
  def add(self, variation: Variation) -> Variation:
    pass

  @abstractmethod
  def getByExperimentId(self, experimentId: int) -> list[Variation]:
    pass
    
  @abstractmethod
  def saveAll(self, variations: list[Variation]) -> list[Variation]:
    pass

  @abstractmethod
  def getById(self, id: int) -> Variation:
    pass

  @abstractmethod
  def edit(self, variation: Variation) -> Variation:
    pass

  @abstractmethod
  def delete(self, variation: Variation):
    pass

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\variation\repository\VariationRepositoryImp.py
from src.variation.repository.VariationRepository import VariationRepository
from src.variation.model.Variation import Variation
from db import DBSessionDep
from sqlmodel import select
from fastapi import status, HTTPException

class VariationRepositoryImp(VariationRepository):
  def __init__(self, db: DBSessionDep):
    self.db = db

  def add(self, variation: Variation) -> Variation:
    self.db.add(variation)
    self.db.commit()
    self.db.refresh(variation)
    return variation

  def getByExperimentId(self, experimentId: int) -> list[Variation]:
    return self.db.exec(
      select(Variation).where(Variation.experimentId == experimentId)
    ).all()

  def saveAll(self, variations: list[Variation]) -> list[Variation]:
    for v in variations:
      self.db.add(v)
    self.db.commit()
    for v in variations:
      self.db.refresh(v)
    return variations

  def getById(self, id: int) -> Variation:
    variation = self.db.get(Variation, id)
    if not variation:
      raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Variation not found")
    return variation

  def edit(self, variation: Variation) -> Variation:
    self.db.add(variation)
    self.db.commit()
    self.db.refresh(variation)
    return variation

  def delete(self, variation: Variation):
    self.db.delete(variation)
    self.db.commit()

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\src\variation\services\VariationService.py
from src.variation.repository.VariationRepository import VariationRepository
from src.experiment.repository.ExperimentRepository import ExperimentRepository
from src.variation.dtos.VariationCreateRequestDto import VariationCreateRequestDto
from src.variation.dtos.VariationResponseDto import VariationResponseDto
from src.variation.dtos.VariationUpdateRequestDto import VariationUpdateRequestDto
from src.variation.dtos.TrafficAllocationRequestDto import TrafficAllocationRequestDto
from src.variation.model.Variation import Variation
from fastapi import HTTPException, status

class VariationService:
  def __init__(
    self, 
    repo: VariationRepository,
    experimentRepo: ExperimentRepository
  ):
    self.repo = repo
    self.experimentRepo = experimentRepo

  def createVariation(self, experimentId: int, reqDto: VariationCreateRequestDto) -> VariationResponseDto:
    self.experimentRepo.getById(experimentId)
    variations = self.repo.getByExperimentId(experimentId)

    newVariation = Variation(
      title=reqDto.title,
      js=reqDto.js,
      css=reqDto.css,
      experimentId=experimentId,
      traffic=0 
    )
    
    variations.append(newVariation)
    self._distributeTrafficEvenly(variations)
    self.repo.saveAll(variations)

    return self._mapToResponse(newVariation)

  # 1. Update a single variation (Title, JS, CSS)
  def updateVariation(self, id: int, reqDto: VariationUpdateRequestDto) -> VariationResponseDto:
    variation = self.repo.getById(id)

    if reqDto.title is not None:
      variation.title = reqDto.title
    if reqDto.js is not None:
      variation.js = reqDto.js
    if reqDto.css is not None:
      variation.css = reqDto.css

    updatedVar = self.repo.edit(variation)
    return self._mapToResponse(updatedVar)

  # 2. Update Traffic Allocation for the whole experiment
  def updateTrafficAllocation(self, experimentId: int, reqDto: TrafficAllocationRequestDto) -> list[VariationResponseDto]:
    # Fetch all actual variations from DB
    dbVariations = self.repo.getByExperimentId(experimentId)
    if not dbVariations:
       raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="No variations found for this experiment")

    # Create a map for quick lookup
    dbVarMap = {v.id: v for v in dbVariations}
    
    # Input validation: Ensure user sent allocations for ALL existing variations
    inputIds = set(a.variationId for a in reqDto.allocations)
    existingIds = set(dbVarMap.keys())

    if inputIds != existingIds:
      raise HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST, 
        detail="Traffic allocation must include all variations belonging to this experiment"
      )

    # Apply updates
    for alloc in reqDto.allocations:
      variation = dbVarMap[alloc.variationId]
      variation.traffic = alloc.traffic
    
    # Save changes
    self.repo.saveAll(dbVariations)

    return [self._mapToResponse(v) for v in dbVariations]

  # Helper: Distribute logic (used in creation)
  def _distributeTrafficEvenly(self, variations: list[Variation]):
    count = len(variations)
    if count > 0:
      base_traffic = 100 // count
      remainder = 100 % count
      for i, var in enumerate(variations):
        extra = 1 if i < remainder else 0
        var.traffic = base_traffic + extra

  def _mapToResponse(self, v: Variation) -> VariationResponseDto:
    return VariationResponseDto(
      id=v.id,
      experimentId=v.experimentId, # type: ignore
      title=v.title,
      traffic=v.traffic, # type: ignore
      js=v.js,
      css=v.css,
      isControl=v.isControl
    )
  
  def getVariations(self, experimentId: int) -> list[VariationResponseDto]:
    self.experimentRepo.getById(experimentId) 
    variations = self.repo.getByExperimentId(experimentId)
    return [self._mapToResponse(v) for v in variations]
  
  def deleteVariation(self, id: int) -> VariationResponseDto:
    variation = self.repo.getById(id)

    if variation.isControl:
      raise HTTPException(
        status_code=status.HTTP_400_BAD_REQUEST, 
        detail="Cannot delete the Control variation!"
      )
    
    self.repo.delete(variation)
    return self._mapToResponse(variation)

file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\static\client-sdk.js
class ABTestingClient {
  /**
   * @param {Object} config
   * @param {string} config.serverBaseUrl - Your API server URL (e.g., "http://localhost:8000")
   * @param {number} config.projectId - The ID of the project this website belongs to
   */
  constructor(config) {
    if (!config.serverBaseUrl || !config.projectId) {
      throw new Error(
        "ABTestingSDK: serverBaseUrl and projectId are required."
      );
    }
    this.serverBaseUrl = config.serverBaseUrl;
    this.projectId = config.projectId;
    this.storageKey = "ab-end-user-id"; // Key for localStorage
  }

  async init() {
    try {
      const decisionData = await this._fetchDecision();

      // --- NEW: Save the User ID to localStorage ---
      // The server returns the ID it used (either the one we sent, or a new random one).
      // We save it so the user remains consistent on next reload.
      if (decisionData.endUserId) {
        localStorage.setItem(this.storageKey, decisionData.endUserId);
      }

      // Apply Decisions (Visual Changes)
      if (decisionData.decisions && Array.isArray(decisionData.decisions)) {
        decisionData.decisions.forEach((decision) => {
          this._applyExperiment(decision);
        });
      }
    } catch (error) {
      console.error("ABTestingSDK Error:", error);
    }
  }

  /**
   * internal: Fetch decision from backend
   */
  async _fetchDecision() {
    // 1. Read User ID from localStorage (was Cookie)
    const userId = localStorage.getItem(this.storageKey);

    const payload = {
      url: window.location.href,
      endUserId: userId ? parseInt(userId) : null,
      projectId: this.projectId,
    };

    const response = await fetch(`${this.serverBaseUrl}/decision`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch decision: ${response.statusText}`);
    }

    return await response.json();
  }

  _applyExperiment(decision) {
    // Inject CSS & JS
    if (decision.experimentCss)
      this._injectCss(decision.experimentCss, `exp-${decision.experimentId}`);
    if (decision.experimentJs) this._executeJs(decision.experimentJs);

    const variation = decision.variation;
    if (variation) {
      if (variation.css)
        this._injectCss(variation.css, `var-${variation.variationId}`);
      if (variation.js) this._executeJs(variation.js);
    }

    // Attach Metric Listeners
    if (decision.metrics && Array.isArray(decision.metrics)) {
      this._setupMetrics(decision.metrics, decision.experimentId);
    }
  }

  _injectCss(cssContent, id) {
    const style = document.createElement("style");
    style.id = `ab-style-${id}`;
    style.innerHTML = cssContent;
    document.head.appendChild(style);
  }

  _executeJs(jsContent) {
    try {
      const scriptFn = new Function(jsContent);
      scriptFn();
    } catch (e) {
      console.error("ABTestingSDK: Error executing variation JS", e);
    }
  }

  _setupMetrics(metrics, experimentId) {
    metrics.forEach((metric) => {
      if (metric.selector) {
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", () =>
            this._attachListener(metric, experimentId)
          );
        } else {
          this._attachListener(metric, experimentId);
        }
      }
    });
  }

  _attachListener(metric, experimentId) {
    const elements = document.querySelectorAll(metric.selector);
    elements.forEach((el) => {
      el.addEventListener(
        "click",
        () => {
          this._trackMetric(metric.id, experimentId);
        },
        { once: false }
      );
    });
  }

  /**
   * internal: Call the backend tracking endpoint
   * @param {number} metricId
   * @param {number} experimentId
   */
  async _trackMetric(metricId, experimentId) {
    try {
      await fetch(`${this.serverBaseUrl}/metrics/track`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          metricsId: metricId,
          experimentId: experimentId, // Pass the experimentId from the SDK,
          custom: false,
        }),
      });
      console.log(`ABTestingSDK: Metric tracked successfully`);
    } catch (error) {
      console.error("ABTestingSDK: Failed to track metric", error);
    }
  }

  /**
   * internal: Call the backend tracking endpoint
   * @param {string} eventName
   * @param {number} experimentId
   */
  async trackCustomMetric(eventName, experimentId) {
    try {
      await fetch(`${this.serverBaseUrl}/metrics/track`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          eventName: eventName,
          experimentId: experimentId, // Pass the experimentId from the SDK
          custom: true,
        }),
      });
      console.log(
        `ABTestingSDK: Custom metric ${eventName} tracked successfully`
      );
    } catch (error) {
      console.error("ABTestingSDK: Failed to track metric", error);
    }
  }
}

window.ABTestingClient = ABTestingClient;


file path: C:\Users\Shahriar Kabir\Documents\Personal\ABTestingToolServer\static\menu.json
[
  {
    "key": "1",
    "label": "User",
    "data": {
      "href": "/user",
      "actions": [
        "act:update-user",
        "act:get-users",
        "act:get-roles",
        "act:get-projects-by-user-and-org",
        "act:get-projects",
        "act:assign-user-to-project",
        "act:remove-user-from-project",
        "act:get-menu-templates"
      ]
    },
    "icon": "pi pi-fw pi-users"
  },
  {
    "key": "2",
    "label": "Role",
    "data": {
      "href": "/role",
      "actions": ["act:create-role", "act:get-roles"]
    },
    "icon": "pi pi-fw pi-shield"
  },
  {
    "key": "7",
    "label": "Menu",
    "icon": "pi pi-fw pi-list",
    "data": {
      "href": "/menu-template",
      "actions": [
        "act:create-menu-template",
        "act:get-menu-template",
        "act:get-menu-templates"
      ]
    }
  },
  {
    "key": "4",
    "label": "Project",
    "data": {
      "href": "/project",
      "actions": ["act:create-project", "act:get-projects"]
    },
    "icon": "pi pi-fw pi-folder"
  },
  {
    "key": "5",
    "label": "Experiment",
    "data": {
      "href": "/experiment",
      "actions": [
        "act:create-experiment",
        "act:get-experiments",
        "act:get-experiment",
        "act:update-experiment",
        "act:create-variation",
        "act:update-variation",
        "act:update-traffic-allocation",
        "act:create-condition",
        "act:get-conditions",
        "act:delete-condition",
        "act:create-metric",
        "act:get-metrics",
        "act:delete-metric",
        "act:track-metric",
        "act:make-decision"
      ]
    },
    "icon": "pi pi-fw pi-bolt"
  }
]


